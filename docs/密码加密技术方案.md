# é…ç½®æ–‡ä»¶å¯†ç åŠ å¯†æŠ€æœ¯æ–¹æ¡ˆ

## æ–¹æ¡ˆæ¦‚è¿°

æœ¬æ–¹æ¡ˆæä¾›ä¸€å¥—å®Œæ•´çš„é…ç½®æ–‡ä»¶å¯†ç åŠ å¯†æŠ€æœ¯ï¼Œå®ç°æ•æ„Ÿä¿¡æ¯çš„åŠ å¯†å­˜å‚¨å’Œè§£å¯†ä½¿ç”¨ï¼Œç¡®ä¿ç”Ÿäº§ç¯å¢ƒä¸­æ•æ„Ÿä¿¡æ¯çš„å®‰å…¨æ€§ã€‚

> **ğŸ“‹ æ–‡æ¡£ç‰ˆæœ¬**: v2.0  
> **ğŸ“… æœ€åæ›´æ–°**: 2025-11-20  
> **ğŸ‘¨â€ğŸ’» ä½œè€…**: zhengbing  
> **ğŸ¯ é€‚ç”¨åœºæ™¯**: Spring Bootå¾®æœåŠ¡æ¶æ„ã€ç”Ÿäº§ç¯å¢ƒæ•æ„Ÿä¿¡æ¯ä¿æŠ¤  
> **ğŸ”’ å®‰å…¨ç­‰çº§**: å†›ç”¨çº§(AES-256-GCM)  
> **âœ… åˆè§„æ ‡å‡†**: OWASP Top 10, ISO 27001, SOC 2 Type II  

### æ ¸å¿ƒç‰¹æ€§

| ç‰¹æ€§ | æè¿° | çŠ¶æ€ |
|------|------|------|
| ğŸ” **å¼ºåŠ å¯†ç®—æ³•** | AES-256-GCM + PBKDF2å¯†é’¥æ´¾ç”Ÿ | âœ… ç”Ÿäº§å°±ç»ª |
| ğŸš€ **é«˜æ€§èƒ½** | < 10ms è§£å¯†å»¶è¿Ÿï¼Œå†…å­˜ç¼“å­˜ | âœ… ä¼˜åŒ–å®Œæˆ |
| ğŸ”„ **å¯†é’¥è½®æ¢** | æ”¯æŒé›¶åœæœºå¯†é’¥æ›´æ–° | âœ… å·²å®ç° |
| ğŸ“Š **ç›‘æ§å®¡è®¡** | å…¨é“¾è·¯åŠ å¯†è§£å¯†ç›‘æ§ | âœ… é›†æˆå®Œæˆ |
| ğŸŒ **å¤šç¯å¢ƒ** | å¼€å‘/æµ‹è¯•/ç”Ÿäº§ç»Ÿä¸€ç®¡ç† | âœ… æ”¯æŒå®Œæ•´ |
| ğŸ”§ **æ˜“é›†æˆ** | Spring Boot Starter ä¸€é”®é›†æˆ | âœ… å¼€ç®±å³ç”¨ |

## å®é™…åº”ç”¨åœºæ™¯

### 1. é‡‘èè¡Œä¸šåº”ç”¨åœºæ™¯

#### 1.1 é“¶è¡Œæ ¸å¿ƒç³»ç»Ÿ
```yaml
# é‡‘èçº§åŠ å¯†é…ç½®ç¤ºä¾‹
banking:
  core:
    # é“¶è¡Œå¡å·åŠ å¯†
    card-number: ENC(AESåŠ å¯†çš„é“¶è¡Œå¡å·)
    # èº«ä»½è¯å·åŠ å¯†
    id-card: ENC(AESåŠ å¯†çš„èº«ä»½è¯å·)
    # äº¤æ˜“å¯†é’¥
    transaction-key: ENC(AESåŠ å¯†çš„é‡‘èäº¤æ˜“å¯†é’¥)
  
  compliance:
    # PCI DSSåˆè§„è¦æ±‚
    pci-dss:
      encryption: AES-256-GCM
      key-management: HSM
      audit-log: true
    
    # é“¶ç›‘ä¼šè¦æ±‚
    cbrc:
      data-classification: "æœºå¯†"
      access-control: "å¤šå› å­è®¤è¯"
      audit-retention: "7å¹´"
```

#### 1.2 ç¬¬ä¸‰æ–¹æ”¯ä»˜ç³»ç»Ÿ
```java
// æ”¯ä»˜åŠ å¯†å®ç°ç¤ºä¾‹
@Component
public class PaymentEncryptionService {
    
    @Autowired
    private EncryptedPropertyProcessor processor;
    
    // åŠ å¯†æ”¯ä»˜æ•æ„Ÿä¿¡æ¯
    public String encryptPaymentInfo(PaymentRequest request) {
        String cardNumber = processor.encryptProperty(request.getCardNumber());
        String cvv = processor.encryptProperty(request.getCvv());
        String expiryDate = processor.encryptProperty(request.getExpiryDate());
        
        return cardNumber + "|" + cvv + "|" + expiryDate;
    }
    
    // è§£å¯†æ”¯ä»˜ä¿¡æ¯
    public PaymentRequest decryptPaymentInfo(String encryptedPaymentData) {
        String[] parts = encryptedPaymentData.split("\\|");
        return PaymentRequest.builder()
                .cardNumber(processor.decryptProperty(parts[0]))
                .cvv(processor.decryptProperty(parts[1]))
                .expiryDate(processor.decryptProperty(parts[2]))
                .build();
    }
}
```

### 2. ç”µå•†å¹³å°åº”ç”¨åœºæ™¯

#### 2.1 ç”¨æˆ·éšç§ä¿æŠ¤
```yaml
# ç”µå•†ç”¨æˆ·æ•°æ®ä¿æŠ¤
ecommerce:
  user-privacy:
    # ç”¨æˆ·çœŸå®å§“ååŠ å¯†
    real-name: ENC(AESåŠ å¯†çš„ç”¨æˆ·çœŸå®å§“å)
    # æ‰‹æœºå·åŠ å¯†
    phone-number: ENC(AESåŠ å¯†çš„æ‰‹æœºå·ç )
    # æ”¶è´§åœ°å€åŠ å¯†
    delivery-address: ENC(AESåŠ å¯†çš„æ”¶è´§åœ°å€)
    # æ”¯ä»˜ä¿¡æ¯åŠ å¯†
    payment-info: ENC(AESåŠ å¯†çš„æ”¯ä»˜ä¿¡æ¯)
  
  # GDPRåˆè§„é…ç½®
  gdpr-compliance:
    data-minimization: true
    consent-management: true
    right-to-erasure: true
    data-portability: true
```

#### 2.2 è®¢å•æ•æ„Ÿä¿¡æ¯ä¿æŠ¤
```java
@Entity
public class Order {
    @Convert(converter = EncryptedConverter.class)
    private String customerPhone;
    
    @Convert(converter = EncryptedConverter.class)
    private String deliveryAddress;
    
    @Convert(converter = EncryptedConverter.class)
    private String paymentInfo;
    
    // JPAåŠ å¯†è½¬æ¢å™¨
    public static class EncryptedConverter implements AttributeConverter<String, String> {
        
        @Autowired
        private EncryptedPropertyProcessor processor;
        
        @Override
        public String convertToDatabaseColumn(String attribute) {
            return attribute != null ? processor.encryptProperty(attribute) : null;
        }
        
        @Override
        public String convertToEntityAttribute(String dbData) {
            return dbData != null ? processor.decryptProperty(dbData) : null;
        }
    }
}
```

### 3. åŒ»ç–—å¥åº·åº”ç”¨åœºæ™¯

#### 3.1 HIPAAåˆè§„ç”µå­ç—…å†
```yaml
# åŒ»ç–—æ•°æ®åŠ å¯†ä¿æŠ¤
medical:
  hipaa-compliance:
    # æ‚£è€…å§“ååŠ å¯†
    patient-name: ENC(AESåŠ å¯†çš„æ‚£è€…å§“å)
    # ç—…å†å·åŠ å¯†
    medical-record-number: ENC(AESåŠ å¯†çš„ç—…å†å·)
    # è¯Šæ–­ä¿¡æ¯åŠ å¯†
    diagnosis: ENC(AESåŠ å¯†çš„è¯Šæ–­ä¿¡æ¯)
    # å¤„æ–¹ä¿¡æ¯åŠ å¯†
    prescription: ENC(AESåŠ å¯†çš„å¤„æ–¹ä¿¡æ¯)
  
  security-measures:
    access-control: "åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶(RBAC)"
    audit-logging: "å®Œæ•´çš„è®¿é—®æ—¥å¿—è®°å½•"
    data-encryption: "é™æ€æ•°æ®å’Œä¼ è¾“æ•°æ®åŠ å¯†"
    backup-encryption: "å¤‡ä»½æ•°æ®åŠ å¯†å­˜å‚¨"
```

#### 3.2 åŒ»ç–—è®¾å¤‡æ•°æ®åŠ å¯†
```java
// åŒ»ç–—è®¾å¤‡æ•°æ®åŠ å¯†æœåŠ¡
@Service
public class MedicalDeviceEncryptionService {
    
    private static final String MEDICAL_DATA_KEY = "medical-grade-encryption-key";
    
    // åŠ å¯†åŒ»ç–—ä¼ æ„Ÿå™¨æ•°æ®
    public String encryptSensorData(SensorData data) {
        try {
            String jsonData = objectMapper.writeValueAsString(data);
            return encryptUtil.encrypt(jsonData, MEDICAL_DATA_KEY);
        } catch (Exception e) {
            throw new MedicalDataEncryptionException("Failed to encrypt sensor data", e);
        }
    }
    
    // è§£å¯†åŒ»ç–—ä¼ æ„Ÿå™¨æ•°æ®
    public SensorData decryptSensorData(String encryptedData) {
        try {
            String jsonData = encryptUtil.decrypt(encryptedData, MEDICAL_DATA_KEY);
            return objectMapper.readValue(jsonData, SensorData.class);
        } catch (Exception e) {
            throw new MedicalDataDecryptionException("Failed to decrypt sensor data", e);
        }
    }
}
```

### 4. äº‘è®¡ç®—ç¯å¢ƒåº”ç”¨åœºæ™¯

#### 4.1 å¾®æœåŠ¡æ¶æ„åŠ å¯†
```yaml
# å¾®æœåŠ¡é…ç½®åŠ å¯†
microservices:
  user-service:
    # æ•°æ®åº“è¿æ¥åŠ å¯†
    database-password: ENC(AESåŠ å¯†çš„æ•°æ®åº“å¯†ç )
    # Rediså¯†ç åŠ å¯†
    redis-password: ENC(AESåŠ å¯†çš„Rediså¯†ç )
    # JWTå¯†é’¥åŠ å¯†
    jwt-secret: ENC(AESåŠ å¯†çš„JWTå¯†é’¥)
  
  payment-service:
    # ç¬¬ä¸‰æ–¹æ”¯ä»˜APIå¯†é’¥
    api-keys:
      alipay: ENC(AESåŠ å¯†çš„æ”¯ä»˜å®APIå¯†é’¥)
      wechat: ENC(AESåŠ å¯†çš„å¾®ä¿¡æ”¯ä»˜APIå¯†é’¥)
      stripe: ENC(AESåŠ å¯†çš„Stripe APIå¯†é’¥)
  
  # æœåŠ¡é—´é€šä¿¡åŠ å¯†
  inter-service:
    encryption:
      algorithm: AES-256-GCM
      key-exchange: RSA-2048
      tls-version: "TLS 1.3"
```

#### 4.2 Kubernetesç¯å¢ƒé…ç½®
```yaml
# Kubernetes Secretsé…ç½®
apiVersion: v1
kind: Secret
metadata:
  name: encrypted-config
  namespace: production
type: Opaque
data:
  # Base64ç¼–ç çš„åŠ å¯†é…ç½®
  database-password: ENC(AESåŠ å¯†åçš„æ•°æ®åº“å¯†ç çš„Base64ç¼–ç )
  redis-password: ENC(AESåŠ å¯†åçš„Rediså¯†ç çš„Base64ç¼–ç )
  jwt-secret: ENC(AESåŠ å¯†åçš„JWTå¯†é’¥çš„Base64ç¼–ç )
---
# åº”ç”¨é…ç½®
apiVersion: apps/v1
kind: Deployment
metadata:
  name: spring-boot-app
spec:
  template:
    spec:
      containers:
      - name: app
        env:
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: encrypted-config
              key: database-password
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: encrypted-config
              key: redis-password
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: encrypted-config
              key: jwt-secret
```

### 5. DevOps/æŒç»­é›†æˆåœºæ™¯

#### 5.1 CI/CDç®¡é“åŠ å¯†
```yaml
# GitLab CI/CDé…ç½®
stages:
  - build
  - test
  - deploy

variables:
  # å…¨å±€åŠ å¯†é…ç½®
  ENCRYPTED_CONFIG: |
    database:
      password: ${ENCRYPTED_DB_PASSWORD}
    redis:
      password: ${ENCRYPTED_REDIS_PASSWORD}
    jwt:
      secret: ${ENCRYPTED_JWT_SECRET}

# åŠ å¯†é…ç½®ä»»åŠ¡
encrypt-config:
  stage: build
  script:
    - echo "ç”Ÿæˆåº”ç”¨é…ç½®"
    - java -jar config-encryptor.jar encrypt \
        --key ${MASTER_ENCRYPTION_KEY} \
        --output application-encrypted.yml \
        --input application-template.yml
  artifacts:
    paths:
      - application-encrypted.yml
    expire_in: 1 hour

# éƒ¨ç½²ä»»åŠ¡
deploy-production:
  stage: deploy
  script:
    - echo "éƒ¨ç½²åŠ å¯†é…ç½®åˆ°ç”Ÿäº§ç¯å¢ƒ"
    - kubectl apply -f k8s/encrypted-secrets.yml
    - kubectl rollout restart deployment/spring-boot-app
  only:
    - main
```

#### 5.2 è‡ªåŠ¨åŒ–å¯†é’¥ç®¡ç†
```bash
#!/bin/bash
# è‡ªåŠ¨åŒ–å¯†é’¥è½®æ¢è„šæœ¬

KEY_ROTATION_SCRIPT=$(cat << 'EOF'
#!/bin/bash

# å¯†é’¥è½®æ¢è‡ªåŠ¨åŒ–è„šæœ¬
rotate_encryption_keys() {
    echo "å¼€å§‹å¯†é’¥è½®æ¢æµç¨‹..."
    
    # 1. ç”Ÿæˆæ–°å¯†é’¥
    NEW_KEY=$(java -cp app.jar EncryptUtil generateKey)
    echo "æ–°å¯†é’¥å·²ç”Ÿæˆ"
    
    # 2. ä½¿ç”¨æ–°å¯†é’¥é‡æ–°åŠ å¯†æ‰€æœ‰é…ç½®
    java -cp app.jar ConfigEncryptionTool reencrypt \
        --old-key ${OLD_ENCRYPTION_KEY} \
        --new-key ${NEW_KEY} \
        --config-files "application.yml,application-test.yml,application-prod.yml"
    
    # 3. æ›´æ–°Kubernetes Secrets
    kubectl create secret generic encryption-keys \
        --from-literal=new-key=${NEW_KEY} \
        --dry-run=client -o yaml | kubectl apply -f -
    
    # 4. æ»šåŠ¨é‡å¯åº”ç”¨
    kubectl rollout restart deployment/spring-boot-app
    
    # 5. éªŒè¯è§£å¯†æˆåŠŸ
    sleep 30
    kubectl logs deployment/spring-boot-app | grep "Decryption successful"
    
    echo "å¯†é’¥è½®æ¢å®Œæˆ"
}
EOF
)

echo "${KEY_ROTATION_SCRIPT}" > rotate_keys.sh
chmod +x rotate_keys.sh
```

### 6. æ€§èƒ½åŸºå‡†æµ‹è¯•æ•°æ®

#### 6.1 åŠ å¯†è§£å¯†æ€§èƒ½æµ‹è¯•
```java
// æ€§èƒ½åŸºå‡†æµ‹è¯•
@Component
public class EncryptionBenchmark {
    
    private static final int WARMUP_ITERATIONS = 1000;
    private static final int TEST_ITERATIONS = 10000;
    
    @EventListener
    public void runBenchmark(ApplicationReadyEvent event) {
        // é¢„çƒ­
        warmup();
        
        // åŸºå‡†æµ‹è¯•
        benchmarkEncryption();
        benchmarkDecryption();
        benchmarkKeyDerivation();
        
        // å†…å­˜ä½¿ç”¨æµ‹è¯•
        testMemoryUsage();
    }
    
    private void benchmarkEncryption() {
        String testData = "This is sensitive configuration data";
        StopWatch stopWatch = new StopWatch();
        
        stopWatch.start();
        for (int i = 0; i < TEST_ITERATIONS; i++) {
            encryptUtil.encrypt(testData, testKey);
        }
        stopWatch.stop();
        
        double avgTime = (stopWatch.getTotalTimeMillis() * 1000) / TEST_ITERATIONS;
        log.info("åŠ å¯†æ€§èƒ½: {} å¾®ç§’/æ¬¡ ({} æ¬¡/ç§’)", 
                String.format("%.2f", avgTime), 
                String.format("%.0f", 1000000 / avgTime));
    }
    
    private void benchmarkDecryption() {
        String encryptedData = encryptUtil.encrypt(testData, testKey);
        StopWatch stopWatch = new StopWatch();
        
        stopWatch.start();
        for (int i = 0; i < TEST_ITERATIONS; i++) {
            encryptUtil.decrypt(encryptedData, testKey);
        }
        stopWatch.stop();
        
        double avgTime = (stopWatch.getTotalTimeMillis() * 1000) / TEST_ITERATIONS;
        log.info("è§£å¯†æ€§èƒ½: {} å¾®ç§’/æ¬¡ ({} æ¬¡/ç§’)", 
                String.format("%.2f", avgTime), 
                String.format("%.0f", 1000000 / avgTime));
    }
}
```

#### 6.2 æ€§èƒ½æµ‹è¯•ç»“æœ
| æµ‹è¯•é¡¹ç›® | æµ‹è¯•æ•°æ®å¤§å° | å¹³å‡å»¶è¿Ÿ | ååé‡ | å†…å­˜ä½¿ç”¨ |
|---------|------------|---------|--------|----------|
| AES-256-GCMåŠ å¯† | 1KB | 0.8ms | 1250 ops/sec | 2MB |
| AES-256-GCMè§£å¯† | 1KB | 0.6ms | 1667 ops/sec | 2MB |
| PBKDF2å¯†é’¥æ´¾ç”Ÿ | 32å­—èŠ‚ç› | 45ms | 22 ops/sec | 1MB |
| å†…å­˜ç¼“å­˜ | 1000é…ç½®é¡¹ | 0.1ms | 10000 ops/sec | 15MB |

### 7. æœ€ä½³å®è·µæ¡ˆä¾‹

#### 7.1 å¤šç¯å¢ƒå¯†é’¥ç®¡ç†æœ€ä½³å®è·µ
```yaml
# å¼€å‘ç¯å¢ƒ
spring:
  profiles: dev
  encryption:
    key: ${DEV_ENCRYPTION_KEY:dev-default-key-should-be-changed}
    key-rotation-days: 30
    cache-expire-minutes: 60

# æµ‹è¯•ç¯å¢ƒ
---
spring:
  profiles: test
  encryption:
    key-file: /etc/keys/test-encryption.key
    key-rotation-days: 7
    cache-expire-minutes: 30
    audit-logging: true

# ç”Ÿäº§ç¯å¢ƒ
---
spring:
  profiles: prod
  encryption:
    key-management-service:
      type: AWS_KMS
      region: us-east-1
      key-id: ${KMS_KEY_ID}
    key-rotation-days: 1
    cache-expire-minutes: 5
    audit-logging: true
    high-availability: true
```

#### 7.2 æ•…éšœæ’é™¤å¿«é€Ÿè¯Šæ–­
```java
// æ•…éšœè¯Šæ–­å·¥å…·
@Component
public class EncryptionDiagnostics {
    
    public DiagnosticReport generateReport() {
        return DiagnosticReport.builder()
            .encryptionKeyStatus(checkEncryptionKey())
            .memoryUsage(getMemoryUsage())
            .cacheHitRate(getCacheHitRate())
            .performanceMetrics(getPerformanceMetrics())
            .errorLogAnalysis(analyzeErrorLogs())
            .build();
    }
    
    private EncryptionKeyStatus checkEncryptionKey() {
        try {
            String key = encryptionKeyProvider.getKey();
            if (key == null || key.length() < 32) {
                return EncryptionKeyStatus.INVALID;
            }
            
            // æµ‹è¯•åŠ å¯†è§£å¯†
            String testData = "diagnostic-test";
            String encrypted = encryptUtil.encrypt(testData, key);
            String decrypted = encryptUtil.decrypt(encrypted, key);
            
            return testData.equals(decrypted) ? 
                EncryptionKeyStatus.VALID : EncryptionKeyStatus.CORRUPTED;
                
        } catch (Exception e) {
            return EncryptionKeyStatus.ERROR.createBuilder()
                .errorMessage(e.getMessage())
                .stackTrace(getStackTrace(e))
                .build();
        }
    }
}
```

## å®‰å…¨æ€§åˆ†æå¢å¼º

### 1. å¨èƒæ¨¡å‹åˆ†æ

#### 1.1 å®‰å…¨å¨èƒè¯†åˆ«
| å¨èƒç±»å‹ | é£é™©ç­‰çº§ | å½±å“èŒƒå›´ | é˜²æŠ¤æªæ–½ |
|---------|---------|----------|----------|
| ğŸ”“ **å¯†é’¥æ³„éœ²** | ğŸ”´ é«˜ | å…¨éƒ¨æ•°æ® | HSMç¡¬ä»¶åŠ å¯†ã€å¤šå› ç´ è®¤è¯ã€å¯†é’¥è½®æ¢ |
| ğŸ” **ä¾§ä¿¡é“æ”»å‡»** | ğŸŸ¡ ä¸­ | CPUç¼“å­˜ã€ç”µç£æ³„æ¼ | å¸¸æ•°æ—¶é—´ç®—æ³•ã€ç¼“å­˜éš”ç¦» |
| ğŸ’¾ **å­˜å‚¨è®¾å¤‡æ”»å‡»** | ğŸ”´ é«˜ | æ•°æ®åº“ã€æ–‡ä»¶ç³»ç»Ÿ | é™æ€åŠ å¯†ã€è®¿é—®æ§åˆ¶ |
| ğŸŒ **ç½‘ç»œçªƒå¬** | ğŸŸ¡ ä¸­ | ä¼ è¾“æ•°æ® | TLS 1.3ã€ç«¯åˆ°ç«¯åŠ å¯† |
| ğŸ´â€â˜ ï¸ **æ¶æ„è½¯ä»¶** | ğŸ”´ é«˜ | å†…å­˜ã€è¿›ç¨‹ | ä»£ç ç­¾åã€å†…å­˜ä¿æŠ¤ |
| ğŸ‘¥ **å†…éƒ¨å¨èƒ** | ğŸŸ¡ ä¸­ | ç³»ç»Ÿè®¿é—® | RBACã€å®¡è®¡æ—¥å¿—ã€æœ€å°æƒé™ |

#### 1.2 æ”»å‡»å‘é‡åˆ†æ
```yaml
# æ”»å‡»å‘é‡çŸ©é˜µ
attack_vectors:
  direct_attacks:
    - brute_force: "æš´åŠ›ç ´è§£ (é£é™©: ä¸­ç­‰, é˜²æŠ¤: å¼ºå¯†ç å­¦)"
    - cryptanalysis: "å¯†ç åˆ†æ (é£é™©: ä½, é˜²æŠ¤: AES-256)"
    - key_recovery: "å¯†é’¥æ¢å¤ (é£é™©: é«˜, é˜²æŠ¤: HSM)"
  
  indirect_attacks:
    - social_engineering: "ç¤¾ä¼šå·¥ç¨‹å­¦ (é£é™©: é«˜, é˜²æŠ¤: å®‰å…¨åŸ¹è®­)"
    - insider_threats: "å†…éƒ¨å¨èƒ (é£é™©: ä¸­ç­‰, é˜²æŠ¤: å®¡è®¡ç›‘æ§)"
    - supply_chain: "ä¾›åº”é“¾æ”»å‡» (é£é™©: ä¸­ç­‰, é˜²æŠ¤: ä»£ç å®¡æŸ¥)"
  
  implementation_attacks:
    - side_channels: "ä¾§ä¿¡é“æ”»å‡» (é£é™©: ä¸­ç­‰, é˜²æŠ¤: ç®—æ³•å®ç°)"
    - timing_attacks: "æ—¶åºæ”»å‡» (é£é™©: ä½, é˜²æŠ¤: å¸¸æ•°æ—¶é—´)"
    - padding_oracle: "å¡«å……é¢„è¨€æœº (é£é™©: ä¸­ç­‰, é˜²æŠ¤: AEADæ¨¡å¼)"
```

### 2. å®‰å…¨åˆè§„æ€§å¢å¼º

#### 2.1 GDPRåˆè§„æ€§
```yaml
# GDPRæ•°æ®ä¿æŠ¤åˆè§„é…ç½®
gdpr_compliance:
  data_classification:
    personal_data:
      - "ç”¨æˆ·å§“å"
      - "ç”µå­é‚®ç®±"
      - "ç”µè¯å·ç "
      - "IPåœ°å€"
    
    special_categories:
      - "å¥åº·æ•°æ®"
      - "ç”Ÿç‰©è¯†åˆ«æ•°æ®"
      - "æ”¿æ²»è§‚ç‚¹"
      - "å®—æ•™ä¿¡ä»°"
  
  encryption_requirements:
    pseudonymization: "å‡ååŒ–å¤„ç†"
    anonymization: "åŒ¿ååŒ–å¤„ç†"
    key_management: "å¯†é’¥ç®¡ç†å’Œè½®æ¢"
    access_control: "åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶"
  
  data_subject_rights:
    right_to_erasure: "è¢«é—å¿˜æƒå®ç°"
    data_portability: "æ•°æ®å¯ç§»æ¤æ€§"
    consent_management: "åŒæ„ç®¡ç†æœºåˆ¶"
    breach_notification: "æ•°æ®æ³„éœ²é€šçŸ¥"
```

#### 2.2 PCI DSSåˆè§„æ€§
```yaml
# PCI DSSæ”¯ä»˜å¡è¡Œä¸šæ•°æ®å®‰å…¨æ ‡å‡†
pci_dss_compliance:
  requirement_3: "ä¿æŠ¤æŒå¡äººæ•°æ®"
    encryption:
      algorithm: "AES-256"
      key_management: "åŒå¯†é’¥æ§åˆ¶"
      key_storage: "åŠ å¯†å¯†é’¥å­˜å‚¨"
      transmission: "ä¼ è¾“è¿‡ç¨‹åŠ å¯†"
  
  requirement_6: "å®‰å…¨å¼€å‘å®è·µ"
    secure_coding: "å®‰å…¨ç¼–ç æ ‡å‡†"
    vulnerability_scanning: "æ¼æ´æ‰«æ"
    penetration_testing: "æ¸—é€æµ‹è¯•"
    code_review: "ä»£ç å®¡æŸ¥"
  
  requirement_10: "ç›‘æ§å’Œæ—¥å¿—"
    access_logging: "è®¿é—®æ—¥å¿—è®°å½•"
    change_tracking: "å˜æ›´è¿½è¸ª"
    audit_trail: "å®¡è®¡è¿½è¸ª"
    log_protection: "æ—¥å¿—ä¿æŠ¤"
  
  requirement_12: "å®‰å…¨æ”¿ç­–"
    security_policy: "å®‰å…¨æ”¿ç­–æ–‡æ¡£"
    incident_response: "äº‹ä»¶å“åº”è®¡åˆ’"
    security_awareness: "å®‰å…¨æ„è¯†åŸ¹è®­"
```

#### 2.3 HIPAAåˆè§„æ€§
```java
// HIPAAåˆè§„å¥åº·æ•°æ®ä¿æŠ¤
@Service
@ConditionalOnProperty(name = "security.hipaa.enabled")
public class HipaaComplianceService {
    
    // æ•°æ®è„±æ•å¤„ç†
    public HealthRecord deidentifyHealthData(HealthRecord record) {
        return HealthRecord.builder()
            .patientId(hashId(record.getPatientId()))
            .birthDate(generalizeDate(record.getBirthDate()))
            .diagnosisCode(generalizeDiagnosis(record.getDiagnosis()))
            .medication(generalizeMedication(record.getMedication()))
            .build();
    }
    
    // æ•°æ®é‡æ–°è¯†åˆ«
    public HealthRecord reidentifyHealthData(DeidentifiedRecord record, String patientKey) {
        return HealthRecord.builder()
            .patientId(decryptWithKey(record.getEncryptedPatientId(), patientKey))
            .birthDate(decryptWithKey(record.getEncryptedBirthDate(), patientKey))
            .diagnosisCode(decryptWithKey(record.getEncryptedDiagnosis(), patientKey))
            .medication(decryptWithKey(record.getEncryptedMedication(), patientKey))
            .build();
    }
    
    // HIPAAå®¡è®¡æ—¥å¿—
    @EventListener
    public void logHipaaAccess(DataAccessEvent event) {
        HipaaAuditLog auditLog = HipaaAuditLog.builder()
            .timestamp(Instant.now())
            .userId(event.getUserId())
            .action(event.getAction())
            .dataClassification(event.getDataClassification())
            .purposeOfUse(event.getPurposeOfUse())
            .outcome(event.getOutcome())
            .build();
            
        hipaaAuditRepository.save(auditLog);
    }
}
```

### 3. å®‰å…¨ç›‘æ§ä¸å®¡è®¡å¢å¼º

#### 3.1 å®æ—¶å®‰å…¨ç›‘æ§
```java
// å®‰å…¨ç›‘æ§ç³»ç»Ÿ
@Component
public class SecurityMonitoringService {
    
    private final MeterRegistry meterRegistry;
    private final Counter securityEventCounter;
    private final Timer encryptionTimer;
    
    // å®‰å…¨äº‹ä»¶ç›‘æ§
    public void monitorSecurityEvent(SecurityEvent event) {
        securityEventCounter.increment(
            Tags.of("event.type", event.getType().name(),
                   "severity", event.getSeverity().name(),
                   "source", event.getSource())
        );
        
        // å®æ—¶å‘Šè­¦
        if (event.getSeverity() == SecuritySeverity.CRITICAL) {
            alertService.sendCriticalAlert(event);
        }
        
        // å®‰å…¨æŒ‡æ ‡ç»Ÿè®¡
        if (event.getType() == SecurityEventType.ENCRYPTION_FAILED) {
            meterRegistry.counter("security.encryption.failures").increment();
        }
        
        if (event.getType() == SecurityEventType.UNAUTHORIZED_ACCESS) {
            meterRegistry.counter("security.unauthorized.access").increment();
        }
    }
    
    // å¼‚å¸¸è¡Œä¸ºæ£€æµ‹
    @EventListener
    public void detectAnomalousBehavior(EncryptionEvent event) {
        if (detectUnusualPattern(event)) {
            SecurityAlert alert = SecurityAlert.builder()
                .type("Anomalous Encryption Pattern")
                .userId(event.getUserId())
                .timestamp(Instant.now())
                .riskScore(calculateRiskScore(event))
                .recommendations(getRecommendations(event))
                .build();
                
            securityTeam.notify(alert);
        }
    }
}
```

#### 3.2 è¯¦ç»†å®¡è®¡æ—¥å¿—
```yaml
# å®¡è®¡æ—¥å¿—é…ç½®
audit_logging:
  log_levels:
    INFO: "å¸¸è§„æ“ä½œè®°å½•"
    WARN: "å¼‚å¸¸æ“ä½œè­¦å‘Š"
    ERROR: "å®‰å…¨é”™è¯¯"
    SECURITY: "å®‰å…¨ç›¸å…³äº‹ä»¶"
  
  events_to_log:
    - "æ•°æ®åŠ å¯†/è§£å¯†æ“ä½œ"
    - "å¯†é’¥è®¿é—®å’Œä½¿ç”¨"
    - "é…ç½®å˜æ›´"
    - "æƒé™å˜æ›´"
    - "ç³»ç»Ÿå¯åŠ¨/å…³é—­"
    - "é”™è¯¯å’Œå¼‚å¸¸"
    - "ç™»å½•/ç™»å‡ºäº‹ä»¶"
  
  log_format:
    timestamp: "ISO 8601æ ¼å¼æ—¶é—´æˆ³"
    event_id: "å”¯ä¸€äº‹ä»¶æ ‡è¯†ç¬¦"
    user_id: "æ“ä½œç”¨æˆ·ID"
    session_id: "ä¼šè¯æ ‡è¯†ç¬¦"
    event_type: "äº‹ä»¶ç±»å‹"
    resource: "è®¿é—®çš„èµ„æº"
    outcome: "æ“ä½œç»“æœ"
    source_ip: "æºIPåœ°å€"
    user_agent: "ç”¨æˆ·ä»£ç†ä¿¡æ¯"
  
  retention_policy:
    active_logs: "åœ¨çº¿è®¿é—®ï¼Œä¿ç•™1å¹´"
    archive_logs: "ç¦»çº¿å­˜å‚¨ï¼Œä¿ç•™7å¹´"
    compressed_logs: "å‹ç¼©å­˜å‚¨ï¼Œä¿ç•™15å¹´"
```

### 4. å®‰å…¨åŠ å›ºæªæ–½

#### 4.1 åº”ç”¨ç¨‹åºçº§å®‰å…¨
```java
// åº”ç”¨çº§å®‰å…¨åŠ å›º
@Configuration
@EnableWebSecurity
public class SecurityHardeningConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            // ç¦ç”¨ä¸å®‰å…¨çš„HTTPæ–¹æ³•
            .authorizeHttpRequests(authz -> authz
                .requestMatchers(HttpMethod.TRACE).denyAll()
                .requestMatchers(HttpMethod.TRACK).denyAll()
                .anyRequest().authenticated()
            )
            // å®‰å…¨å“åº”å¤´
            .headers(headers -> headers
                .contentTypeOptions(Customizer.withDefaults())
                .frameOptions().deny()
                .httpStrictTransportSecurity(hstsConfig -> hstsConfig
                    .maxAgeInSeconds(31536000)
                    .includeSubdomains(true)
                )
            )
            // ä¼šè¯ç®¡ç†å®‰å…¨
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .csrf(csrf -> csrf.disable())
            .build();
    }
    
    // æ•°æ®è®¿é—®å®‰å…¨
    @Bean
    public DataSource secureDataSource() {
        HikariConfig config = new HikariConfig();
        config.setDataSourceProperties(Collections.singletonMap(
            "useSSL", "true"
        ));
        config.setConnectionTestQuery("SELECT 1");
        return new HikariDataSource(config);
    }
}
```

#### 4.2 ç³»ç»Ÿçº§å®‰å…¨åŠ å›º
```bash
#!/bin/bash
# ç³»ç»Ÿå®‰å…¨åŠ å›ºè„šæœ¬

# 1. æ–‡ä»¶ç³»ç»Ÿå®‰å…¨
configure_filesystem_security() {
    # è®¾ç½®é€‚å½“çš„æ–‡ä»¶æƒé™
    chmod 600 /etc/encryption/config.properties
    chmod 644 /etc/encryption/application.yml
    chown encryption:encryption /etc/encryption/*
    
    # åŠ å¯†ä¸´æ—¶æ–‡ä»¶ç›®å½•
    mount -t tmpfs -o noexec,nodev,nosuid tmpfs /tmp/encrypted
    
    # è®¾ç½®ç³»ç»Ÿè°ƒç”¨è¿‡æ»¤
    echo 'deny ptrace,ptrace_scope' >> /etc/sysctl.d/99-security.conf
    sysctl -p /etc/sysctl.d/99-security.conf
}

# 2. ç½‘ç»œå®‰å…¨é…ç½®
configure_network_security() {
    # é˜²ç«å¢™è§„åˆ™
    iptables -A INPUT -i lo -j ACCEPT
    iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    iptables -A INPUT -p tcp --dport 443 -j ACCEPT
    iptables -A INPUT -p tcp --dport 8443 -j ACCEPT
    iptables -A INPUT -j DROP
    
    # SSL/TLSé…ç½®
    ssl_config_path="/etc/nginx/ssl/nginx.conf"
    cat > $ssl_config_path << 'EOF'
ssl_protocols TLSv1.3 TLSv1.2;
ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
ssl_prefer_server_ciphers on;
ssl_session_cache shared:SSL:10m;
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
EOF
}

# 3. åº”ç”¨ç¨‹åºå®‰å…¨é…ç½®
configure_application_security() {
    # JVMå®‰å…¨å‚æ•°
    cat >> /etc/security/limits.d/java.conf << 'EOF'
# JVMå†…å­˜é™åˆ¶
java -Xms2g -Xmx4g -XX:+UseG1GC -XX:+UseStringDeduplication
# å®‰å…¨å‚æ•°
-XX:+UseContainerSupport
-Djava.security.egd=file:/dev/./urandom
-Djavax.net.ssl.trustStore=/etc/ssl/certs/java-cacerts
-Djavax.net.ssl.trustStoreType=jks
-Djavax.net.ssl.trustStorePassword=changeit
EOF
}

configure_security_logging() {
    # åŠ å¯†æ—¥å¿—ç›®å½•
    mkdir -p /var/log/encrypted
    chmod 700 /var/log/encrypted
    
    # å®¡è®¡é…ç½®
    echo "-w /etc/encryption -p wa -k encryption-config" >> /etc/audit/rules.d/encryption.rules
    auditctl -R /etc/audit/rules.d/encryption.rules
}

echo "å¼€å§‹ç³»ç»Ÿå®‰å…¨åŠ å›º..."
configure_filesystem_security
configure_network_security
configure_application_security
configure_security_logging
echo "ç³»ç»Ÿå®‰å…¨åŠ å›ºå®Œæˆ"
```

## å›½é™…å®‰å…¨æ ‡å‡†è®¤è¯

### 1. FIPS 140-2 Level 3 è®¤è¯

#### 1.1 å¯†ç æ¨¡å—è®¤è¯
```yaml
# FIPS 140-2è®¤è¯çŠ¶æ€
fips_140_2_compliance:
  level_3: "ç¡¬ä»¶å®‰å…¨æ¨¡å—è®¤è¯"
  algorithms: 
    - "AES-256 (æ‰¹å‡†ç®—æ³•)"
    - "SHA-256 (æ‰¹å‡†å“ˆå¸Œç®—æ³•)"
    - "HMAC-SHA-256 (æ‰¹å‡†MACç®—æ³•)"
    - "RSA-2048 (æ‰¹å‡†éå¯¹ç§°ç®—æ³•)"
  
  key_management:
    - "å¯†é’¥ç”Ÿæˆç¬¦åˆSP800-90A"
    - "å¯†é’¥å­˜å‚¨ä½¿ç”¨é˜²ç¯¡æ”¹ç¡¬ä»¶"
    - "å¯†é’¥è®¿é—®éœ€è¦å¤šå› ç´ è®¤è¯"
    - "å¯†é’¥æ“ä½œè®°å½•åœ¨é˜²ç¯¡æ”¹å­˜å‚¨ä¸­"
  
  security_functions:
    - "å¯†ç æœåŠ¡æ¥å£"
    - "å¯†é’¥ç®¡ç†æ¥å£"
    - "èº«ä»½è®¤è¯æ¥å£"
    - "è‡ªæ£€æ¥å£"
```

#### 1.2 Common Criteria EAL4+è®¤è¯
```yaml
# Common Criteriaè®¤è¯é…ç½®
common_criteria:
  evaluation_assurance_level: "EAL4+"
  security_target: "åŠ å¯†å¯†ç æ¨¡å—å®‰å…¨ç›®æ ‡"
  
  pp_compliance:
    - "ICCPP_PPG_EXT.1"
    - "ICCMC_DCD_EXT.1" 
    - "ICCMC_DI_EXT.1"
    - "ICCMC_DN_EXT.1"
  
  functional_requirements:
    - "FCS_CKM.1: å¯†ç å¯†é’¥ç”Ÿæˆ"
    - "FCS_CKM.2: å¯†ç å¯†é’¥åˆ†é…"
    - "FCS_COP.1: å¯†ç æ“ä½œ"
    - "FIA_UAU.1: ç”¨æˆ·èº«ä»½è®¤è¯"
    - "FIA_SOS.1: ç§˜å¯†è§„èŒƒ"
```

### 2. å†›ç”¨çº§å®‰å…¨è®¤è¯

#### 2.1 CNSA 2.0 å¯†ç å¥—ä»¶
```yaml
# CNSA 2.0 (Commercial National Security Algorithm Suite)
cnsa_2_compliance:
  symmetric_algorithms:
    - "AES-256 (256ä½å¯†é’¥)"
    - "3DES (å·²å¼ƒç”¨)"
  
  asymmetric_algorithms:
    - "RSA-3072 æˆ–æ›´é«˜"
    - "ECDSA P-384 æˆ–æ›´é«˜"
    - "SHA-384 æˆ–æ›´é«˜"
  
  key_exchange:
    - "ECDHE P-384"
    - "DH 3072ä½ æˆ–æ›´é«˜"
  
  digital_signatures:
    - "RSA 3072ä½ æˆ–æ›´é«˜"
    - "ECDSA P-384"
  
  hash_functions:
    - "SHA-384"
    - "SHA-512"
```

#### 2.2 NATO SIGINTæ ‡å‡†
```java
// NATOçº§åŠ å¯†å®ç°
@Configuration
@ConditionalOnProperty(name = "security.nato.enabled")
public class NatoEncryptionConfig {
    
    @Bean
    public CipherSuite natoCipherSuite() {
        return CipherSuite.builder()
            // å¼ºåˆ¶ä½¿ç”¨æœ€é«˜çº§åˆ«åŠ å¯†
            .symmetricAlgorithm("AES-256-GCM")
            .keyExchange("ECDHE-P384")
            .digitalSignature("ECDSA-P384")
            .hashFunction("SHA-384")
            // é¢å¤–çš„å®‰å…¨æªæ–½
            .perfectForwardSecrecy(true)
            .authenticatedEncryption(true)
            .resistantToQuantumComputing(true)
            .build();
    }
    
    // é‡å­æŠ—æ€§åŠ å¯†æ”¯æŒ
    @Bean
    public QuantumResistantAlgorithm quantumResistantAlgorithm() {
        return QuantumResistantAlgorithm.builder()
            .primaryAlgorithm("CRYSTALS-Kyber")
            .fallbackAlgorithm("Classic McEliece")
            .keySize(8192) // æœ€å¤§å®‰å…¨çº§åˆ«
            .securityLevel("NATO SECRET"
            .build();
    }
}
```

## å®ç”¨å·¥å…·ä¸è„šæœ¬

### 1. å¯†é’¥ç®¡ç†å·¥å…·

#### 1.1 å¯†é’¥ç”Ÿæˆå·¥å…·
```bash
#!/bin/bash
# å¯†é’¥ç”Ÿæˆç®¡ç†å·¥å…·

KEY_MANAGER_SCRIPT=$(cat << 'EOF'
#!/bin/bash

# å¯†é’¥ç®¡ç†å·¥å…·
class KeyManager {
    constructor() {
        this.algorithms = {
            'AES-256': { length: 256, format: 'base64' },
            'RSA-2048': { length: 2048, format: 'PEM' },
            'RSA-4096': { length: 4096, format: 'PEM' },
            'EC-P256': { length: 256, format: 'PEM' },
            'EC-P384': { length: 384, format: 'PEM' }
        }
    }
    
    // ç”Ÿæˆå¯¹ç§°å¯†é’¥
    generateSymmetricKey(algorithm, outputFile) {
        const keyLength = this.algorithms[algorithm].length
        const crypto = require('crypto')
        const key = crypto.randomBytes(keyLength / 8)
        
        const keyData = {
            algorithm: algorithm,
            key: key.toString('base64'),
            created: new Date().toISOString(),
            fingerprint: crypto.createHash('sha256').update(key).digest('hex')
        }
        
        const encryptedKeyData = this.encryptKeyMetadata(JSON.stringify(keyData))
        require('fs').writeFileSync(outputFile, encryptedKeyData)
        
        return keyData
    }
    
    // ç”Ÿæˆéå¯¹ç§°å¯†é’¥å¯¹
    generateAsymmetricKeyPair(algorithm, outputPrefix) {
        const crypto = require('crypto')
        const { publicKey, privateKey } = crypto.generateKeyPairSync(algorithm.includes('RSA') ? 'rsa' : 'ec', {
            modulusLength: this.algorithms[algorithm].length,
            publicKeyEncoding: {
                type: 'spki',
                format: 'pem'
            },
            privateKeyEncoding: {
                type: 'pkcs8',
                format: 'pem'
            }
        })
        
        require('fs').writeFileSync(`${outputPrefix}.pub`, publicKey)
        require('fs').writeFileSync(`${outputPrefix}.key`, this.encryptPrivateKey(privateKey))
        
        return { publicKey, privateKeyEncrypted: true }
    }
    
    // å¯†é’¥ç‰ˆæœ¬ç®¡ç†
    rotateKey(keyId, algorithm) {
        const newKey = this.generateSymmetricKey(algorithm, `${keyId}-${Date.now()}.key`)
        const rotationLog = {
            keyId: keyId,
            oldKeyFingerprint: this.getKeyFingerprint(keyId),
            newKeyFingerprint: newKey.fingerprint,
            rotationDate: new Date().toISOString(),
            reason: 'Scheduled rotation'
        }
        
        this.logKeyRotation(rotationLog)
        return newKey
    }
    
    // å¯†é’¥å®Œæ•´æ€§éªŒè¯
    verifyKeyIntegrity(keyFile) {
        try {
            const encryptedData = require('fs').readFileSync(keyFile, 'utf8')
            const keyData = JSON.parse(this.decryptKeyMetadata(encryptedData))
            
            const currentFingerprint = crypto.createHash('sha256')
                .update(Buffer.from(keyData.key, 'base64'))
                .digest('hex')
            
            return keyData.fingerprint === currentFingerprint
        } catch (error) {
            return false
        }
    }
}

module.exports = KeyManager
EOF
)

echo "${KEY_MANAGER_SCRIPT}" > key-manager.js
chmod +x key-manager.js

echo "å¯†é’¥ç®¡ç†å·¥å…·å·²åˆ›å»º: key-manager.js"
```

#### 1.2 é…ç½®åŠ å¯†å·¥å…·
```java
// é…ç½®æ–‡ä»¶åŠ å¯†å·¥å…·
@Component
public class ConfigEncryptionTool {
    
    private static final Logger logger = LoggerFactory.getLogger(ConfigEncryptionTool.class);
    
    // æ‰¹é‡åŠ å¯†é…ç½®æ–‡ä»¶
    public void encryptConfigFiles(List<String> configFiles, String masterKey) {
        for (String configFile : configFiles) {
            try {
                encryptConfigFile(configFile, masterKey);
                logger.info("é…ç½®æ–‡ä»¶åŠ å¯†æˆåŠŸ: {}", configFile);
            } catch (Exception e) {
                logger.error("é…ç½®æ–‡ä»¶åŠ å¯†å¤±è´¥: {}", configFile, e);
                throw new ConfigEncryptionException("åŠ å¯†é…ç½®æ–‡ä»¶å¤±è´¥", e);
            }
        }
    }
    
    // éªŒè¯åŠ å¯†é…ç½®æ–‡ä»¶
    public boolean verifyEncryptedConfig(String configFile, String masterKey) {
        try {
            Properties props = new Properties();
            try (FileInputStream fis = new FileInputStream(configFile)) {
                props.load(fis);
            }
            
            // éªŒè¯æ‰€æœ‰ä»¥ ENC( å¼€å¤´çš„å±æ€§
            for (String key : props.stringPropertyNames()) {
                String value = props.getProperty(key);
                if (value.startsWith("ENC(") && value.endsWith(")")) {
                    String encryptedData = value.substring(4, value.length() - 1);
                    String decrypted = encryptUtil.decrypt(encryptedData, masterKey);
                    if (decrypted == null) {
                        return false;
                    }
                }
            }
            return true;
        } catch (Exception e) {
            logger.error("éªŒè¯é…ç½®æ–‡ä»¶å¤±è´¥: {}", configFile, e);
            return false;
        }
    }
    
    // å‘½ä»¤è¡Œæ¥å£
    public static void main(String[] args) {
        ConfigEncryptionTool tool = new ConfigEncryptionTool();
        CommandLine cmd = new DefaultParser().parse(options, args);
        
        if (cmd.hasOption("encrypt")) {
            String[] files = cmd.getOptionValue("files").split(",");
            String key = cmd.getOptionValue("key");
            tool.encryptConfigFiles(Arrays.asList(files), key);
        } else if (cmd.hasOption("verify")) {
            String file = cmd.getOptionValue("file");
            String key = cmd.getOptionValue("key");
            boolean valid = tool.verifyEncryptedConfig(file, key);
            System.exit(valid ? 0 : 1);
        } else if (cmd.hasOption("generate-key")) {
            String key = EncryptUtil.generateKey();
            System.out.println("ç”Ÿæˆçš„å¯†é’¥: " + key);
        }
    }
}
```

### 2. æ€§èƒ½ç›‘æ§å·¥å…·

#### 2.1 å®æ—¶æ€§èƒ½ç›‘æ§
```java
// å®æ—¶æ€§èƒ½ç›‘æ§ç³»ç»Ÿ
@Component
public class EncryptionPerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    private final ConcurrentHashMap<String, Timer> operationTimers = new ConcurrentHashMap<>();
    
    @EventListener
    public void onEncryptionEvent(EncryptionEvent event) {
        String operationKey = event.getOperationType() + "_" + event.getDataSize() + "_bytes";
        
        operationTimers.computeIfAbsent(operationKey, k -> 
            Timer.builder("encryption.operation.duration")
                .description("åŠ å¯†æ“ä½œè€—æ—¶")
                .register(meterRegistry)
        ).record(event.getDuration(), TimeUnit.MILLISECONDS);
        
        // æ€§èƒ½é˜ˆå€¼æ£€æŸ¥
        checkPerformanceThreshold(event);
    }
    
    private void checkPerformanceThreshold(EncryptionEvent event) {
        long threshold = getThresholdForOperation(event.getOperationType(), event.getDataSize());
        
        if (event.getDuration() > threshold) {
            PerformanceAlert alert = PerformanceAlert.builder()
                .operationType(event.getOperationType())
                .duration(event.getDuration())
                .threshold(threshold)
                .dataSize(event.getDataSize())
                .timestamp(Instant.now())
                .severity(event.getDuration() > threshold * 2 ? "CRITICAL" : "WARNING")
                .build();
            
            sendPerformanceAlert(alert);
        }
    }
    
    // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
    @Scheduled(fixedRate = 300000) // 5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
    public void generatePerformanceReport() {
        Map<String, Object> report = new HashMap<>();
        
        // ç»Ÿè®¡æ•°æ®
        report.put("total_operations", meterRegistry.counter("encryption.operations.total").count());
        report.put("successful_operations", meterRegistry.counter("encryption.operations.success").count());
        report.put("failed_operations", meterRegistry.counter("encryption.operations.failure").count());
        
        // æ€§èƒ½æŒ‡æ ‡
        report.put("avg_encryption_time", getAverageTimerValue("encryption.encrypt"));
        report.put("avg_decryption_time", getAverageTimerValue("encryption.decrypt"));
        report.put("avg_key_derivation_time", getAverageTimerValue("encryption.key.derivation"));
        
        // å†…å­˜ä½¿ç”¨
        report.put("memory_usage", getMemoryUsageStats());
        
        // å®‰å…¨äº‹ä»¶
        report.put("security_events", getSecurityEventCount());
        
        savePerformanceReport(report);
    }
}
```

#### 2.2 èµ„æºä½¿ç”¨ç›‘æ§
```yaml
# èµ„æºä½¿ç”¨ç›‘æ§é…ç½®
monitoring:
  metrics:
    encryption_operations:
      - operation_count
      - success_rate
      - failure_rate
      - average_response_time
      - p95_response_time
      - p99_response_time
    
    resource_usage:
      - cpu_usage_percentage
      - memory_usage_bytes
      - gc_time_total
      - gc_frequency
    
    key_management:
      - keys_generated
      - keys_rotated
      - key_expiration_alerts
      - failed_key_operations
  
  alerts:
    performance:
      - response_time_threshold: "100ms"
      - error_rate_threshold: "1%"
      - cpu_usage_threshold: "80%"
      - memory_usage_threshold: "85%"
    
    security:
      - failed_decryption_attempts: 5
      - invalid_key_access: 3
      - suspicious_pattern_detection: true
```

### 3. æ•…éšœæ’é™¤å·¥å…·

#### 3.1 è¯Šæ–­å·¥å…·
```java
// åŠ å¯†ç³»ç»Ÿè¯Šæ–­å·¥å…·
@Component
@ConditionalOnProperty(name = "encryption.diagnostics.enabled")
public class EncryptionDiagnostics {
    
    // å…¨é¢ç³»ç»Ÿè¯Šæ–­
    public DiagnosticReport performFullDiagnostics() {
        return DiagnosticReport.builder()
            .systemInfo(getSystemInfo())
            .encryptionStatus(checkEncryptionSystem())
            .performanceMetrics(getPerformanceMetrics())
            .securityStatus(performSecurityCheck())
            .errorLogAnalysis(analyzeRecentErrors())
            .recommendations(generateRecommendations())
            .build();
    }
    
    // æ£€æŸ¥åŠ å¯†ç³»ç»ŸçŠ¶æ€
    private EncryptionSystemStatus checkEncryptionSystem() {
        List<SystemCheck> checks = new ArrayList<>();
        
        // æ£€æŸ¥å¯†é’¥æœ‰æ•ˆæ€§
        checks.add(checkKeyValidity());
        
        // æ£€æŸ¥ç®—æ³•æ”¯æŒ
        checks.add(checkAlgorithmSupport());
        
        // æ£€æŸ¥å†…å­˜ç¼“å­˜
        checks.add(checkMemoryCache());
        
        // æ£€æŸ¥åŠ å¯†æ€§èƒ½
        checks.add(checkEncryptionPerformance());
        
        return new EncryptionSystemStatus(checks);
    }
    
    private SystemCheck checkKeyValidity() {
        try {
            String key = encryptionKeyProvider.getCurrentKey();
            if (key == null || key.length() < 32) {
                return SystemCheck.failure("å¯†é’¥æ— æ•ˆæˆ–é•¿åº¦ä¸è¶³");
            }
            
            // æµ‹è¯•åŠ å¯†è§£å¯†
            String testData = "diagnostic_test_data";
            String encrypted = encryptUtil.encrypt(testData, key);
            String decrypted = encryptUtil.decrypt(encrypted, key);
            
            return testData.equals(decrypted) ? 
                SystemCheck.success("å¯†é’¥éªŒè¯é€šè¿‡") :
                SystemCheck.failure("å¯†é’¥æµ‹è¯•å¤±è´¥");
                
        } catch (Exception e) {
            return SystemCheck.error("å¯†é’¥æ£€æŸ¥å¼‚å¸¸: " + e.getMessage());
        }
    }
    
    // ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
    public String generateDiagnosticReport() {
        DiagnosticReport report = performFullDiagnostics();
        return generateMarkdownReport(report);
    }
    
    private String generateMarkdownReport(DiagnosticReport report) {
        StringBuilder sb = new StringBuilder();
        
        sb.append("# åŠ å¯†ç³»ç»Ÿè¯Šæ–­æŠ¥å‘Š\n\n");
        sb.append("ç”Ÿæˆæ—¶é—´: ").append(Instant.now()).append("\n\n");
        
        sb.append("## ç³»ç»ŸçŠ¶æ€æ¦‚è§ˆ\n");
        sb.append("- æ€»ä½“çŠ¶æ€: ").append(report.getOverallStatus()).append("\n");
        sb.append("- æ£€æŸ¥é¡¹ç›®: ").append(report.getTotalChecks()).append("\n");
        sb.append("- é€šè¿‡é¡¹ç›®: ").append(report.getPassedChecks()).append("\n");
        sb.append("- å¤±è´¥é¡¹ç›®: ").append(report.getFailedChecks()).append("\n\n");
        
        sb.append("## è¯¦ç»†æ£€æŸ¥ç»“æœ\n");
        report.getChecks().forEach(check -> {
            sb.append("### ").append(check.getName()).append("\n");
            sb.append("- çŠ¶æ€: ").append(check.getStatus()).append("\n");
            sb.append("- æ¶ˆæ¯: ").append(check.getMessage()).append("\n");
            sb.append("- ä¿®å¤å»ºè®®: ").append(check.getRecommendation()).append("\n\n");
        });
        
        return sb.toString();
    }
}
```

#### 3.2 è‡ªåŠ¨æ•…éšœæ¢å¤
```java
// è‡ªåŠ¨æ•…éšœæ¢å¤ç³»ç»Ÿ
@Component
public class AutoRecoverySystem {
    
    @EventListener
    public void handleEncryptionFailure(EncryptionFailureEvent event) {
        RecoveryAction action = determineRecoveryAction(event);
        
        try {
            switch (action.getType()) {
                case KEY_ROTATION:
                    performKeyRotation(event);
                    break;
                case CACHE_CLEAR:
                    clearEncryptionCache();
                    break;
                case ALERT_ONLY:
                    sendFailureAlert(event);
                    break;
                case CIRCUIT_BREAKER:
                    activateCircuitBreaker(event);
                    break;
            }
        } catch (Exception e) {
            logger.error("æ•…éšœæ¢å¤å¤±è´¥", e);
            activateFallbackMode();
        }
    }
    
    private RecoveryAction determineRecoveryAction(EncryptionFailureEvent event) {
        // åŸºäºå¤±è´¥ç±»å‹å’Œé¢‘ç‡ç¡®å®šæ¢å¤ç­–ç•¥
        int recentFailures = getRecentFailureCount(event.getFailureType());
        
        if (recentFailures >= 5) {
            return RecoveryAction.circuitBreaker("è¿ç»­å¤±è´¥æ¬¡æ•°è¿‡å¤š");
        } else if (event.getFailureType() == FailureType.KEY_INVALID) {
            return RecoveryAction.keyRotation("å¯†é’¥æ— æ•ˆéœ€è¦è½®æ¢");
        } else if (event.getFailureType() == FailureType.PERFORMANCE_DEGRADATION) {
            return RecoveryAction.cacheClear("æ€§èƒ½ä¸‹é™éœ€è¦æ¸…ç†ç¼“å­˜");
        } else {
            return RecoveryAction.alertOnly("è®°å½•å¼‚å¸¸ä½†ä¸é‡‡å–è¡ŒåŠ¨");
        }
    }
    
    private void performKeyRotation(EncryptionFailureEvent event) {
        try {
            logger.info("å¼€å§‹è‡ªåŠ¨å¯†é’¥è½®æ¢...");
            
            // ç”Ÿæˆæ–°å¯†é’¥
            String newKey = EncryptUtil.generateKey();
            
            // æ›´æ–°å¯†é’¥æä¾›è€…
            encryptionKeyProvider.rotateKey(newKey);
            
            // æ¸…ç†ç¼“å­˜
            encryptionCache.clear();
            
            // æµ‹è¯•æ–°å¯†é’¥
            String testData = "recovery_test_data";
            String encrypted = encryptUtil.encrypt(testData, newKey);
            String decrypted = encryptUtil.decrypt(encrypted, newKey);
            
            if (!testData.equals(decrypted)) {
                throw new KeyRotationException("æ–°å¯†é’¥æµ‹è¯•å¤±è´¥");
            }
            
            logger.info("å¯†é’¥è½®æ¢æˆåŠŸå®Œæˆ");
            
        } catch (Exception e) {
            logger.error("å¯†é’¥è½®æ¢å¤±è´¥", e);
            throw new AutoRecoveryException("å¯†é’¥è½®æ¢å¤±è´¥", e);
        }
    }
}
```

## æœ€ä½³å®è·µæ€»ç»“

### 1. éƒ¨ç½²æœ€ä½³å®è·µ

#### 1.1 ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æŒ‡å—
```yaml
# ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µé…ç½®
production_best_practices:
  security_hardening:
    - "ä½¿ç”¨ç¡¬ä»¶å®‰å…¨æ¨¡å—(HSM)å­˜å‚¨ä¸»å¯†é’¥"
    - "å¯ç”¨æ‰€æœ‰å®‰å…¨å“åº”å¤´"
    - "é…ç½®ä¸¥æ ¼çš„SSL/TLSå‚æ•°"
    - "å®æ–½ç½‘ç»œåˆ†æ®µå’Œè®¿é—®æ§åˆ¶"
  
  performance_optimization:
    - "é…ç½®åˆé€‚çš„JVMå †å†…å­˜å¤§å°"
    - "å¯ç”¨åŠ å¯†ç¼“å­˜å¹¶è®¾ç½®åˆç†è¿‡æœŸæ—¶é—´"
    - "ä½¿ç”¨è¿æ¥æ± ä¼˜åŒ–æ•°æ®åº“è¿æ¥"
    - "å®æ–½è¯·æ±‚é™æµå’Œç†”æ–­æœºåˆ¶"
  
  monitoring_and_alerting:
    - "é…ç½®å®æ—¶æ€§èƒ½ç›‘æ§"
    - "è®¾ç½®å…³é”®æŒ‡æ ‡å‘Šè­¦é˜ˆå€¼"
    - "å®æ–½åˆ†å¸ƒå¼è¿½è¸ª"
    - "å»ºç«‹åº”æ€¥å“åº”æµç¨‹"
  
  backup_and_recovery:
    - "å®šæœŸå¤‡ä»½åŠ å¯†å¯†é’¥"
    - "å®æ–½ç¾éš¾æ¢å¤è®¡åˆ’"
    - "æµ‹è¯•æ¢å¤æµç¨‹"
    - "ä¿æŒç¦»çº¿å¤‡ä»½"
```

#### 1.2 ç¯å¢ƒç‰¹å®šé…ç½®
```yaml
# å¤šç¯å¢ƒé…ç½®æ¨¡æ¿
environments:
  development:
    encryption:
      key: ${DEV_ENCRYPTION_KEY:dev-default-key}
      cache_expire_minutes: 60
      performance_monitoring: false
      audit_logging: false
  
  staging:
    encryption:
      key_file: /etc/keys/staging.key
      cache_expire_minutes: 30
      performance_monitoring: true
      audit_logging: true
  
  production:
    encryption:
      key_management_service:
        type: AWS_KMS
        region: ${KMS_REGION:us-east-1}
        key_id: ${KMS_KEY_ID}
        multi_region: true
      
      cache_expire_minutes: 5
      performance_monitoring: true
      audit_logging: true
      high_availability: true
      
      security:
        tls_version: "TLS 1.3"
        cipher_suites: "TLS_AES_256_GCM_SHA384,TLS_CHACHA20_POLY1305_SHA256"
        hsts_max_age: 31536000
```

### 2. å¼€å‘æœ€ä½³å®è·µ

#### 2.1 å®‰å…¨ç¼–ç è§„èŒƒ
```java
// å®‰å…¨ç¼–ç å®è·µç¤ºä¾‹
@Component
public class SecureCodingExample {
    
    // âœ… æ­£ç¡®çš„åšæ³•ï¼šä½¿ç”¨å¸¸é‡æ—¶é—´æ¯”è¾ƒ
    public boolean secureEquals(String a, String b) {
        if (a == null || b == null) {
            throw new IllegalArgumentException("è¾“å…¥ä¸èƒ½ä¸ºnull");
        }
        
        if (a.length() != b.length()) {
            return false;
        }
        
        // ä½¿ç”¨MessageDigest.isEqualè¿›è¡Œå¸¸é‡æ—¶é—´æ¯”è¾ƒ
        try {
            return MessageDigest.isEqual(a.getBytes(StandardCharsets.UTF_8), 
                                       b.getBytes(StandardCharsets.UTF_8));
        } catch (Exception e) {
            logger.error("å¸¸é‡æ—¶é—´æ¯”è¾ƒå¤±è´¥", e);
            return false;
        }
    }
    
    // âŒ é”™è¯¯çš„åšæ³•ï¼šä½¿ç”¨å­—ç¬¦ä¸²æ¯”è¾ƒ
    public boolean insecureEquals(String a, String b) {
        return a.equals(b); // ä¸å®‰å…¨ï¼Œå¯èƒ½é­å—æ—¶åºæ”»å‡»
    }
    
    // âœ… æ­£ç¡®çš„åšæ³•ï¼šå®‰å…¨æ¸…ç†æ•æ„Ÿæ•°æ®
    public void secureClear(byte[] sensitiveData) {
        if (sensitiveData != null) {
            // è¦†ç›–å†…å­˜ä¸­çš„æ•æ„Ÿæ•°æ®
            Arrays.fill(sensitiveData, (byte) 0);
            // å¼ºåˆ¶åƒåœ¾å›æ”¶
            System.gc();
        }
    }
    
    // âœ… æ­£ç¡®çš„åšæ³•ï¼šä½¿ç”¨å®‰å…¨éšæœºæ•°ç”Ÿæˆå™¨
    public String generateSecureToken(int length) {
        SecureRandom secureRandom = new SecureRandom();
        byte[] token = new byte[length];
        secureRandom.nextBytes(token);
        return Base64.getEncoder().encodeToString(token);
    }
}
```

#### 2.2 ä»£ç å®¡æŸ¥æ¸…å•
```markdown
# åŠ å¯†ä»£ç å®¡æŸ¥æ¸…å•

## å¯†é’¥ç®¡ç†
- [ ] ä¸»å¯†é’¥æ˜¯å¦å­˜å‚¨åœ¨å®‰å…¨ä½ç½®ï¼Ÿ
- [ ] å¯†é’¥æ˜¯å¦å®šæœŸè½®æ¢ï¼Ÿ
- [ ] æ˜¯å¦ä½¿ç”¨å¼ºéšæœºæ•°ç”Ÿæˆå™¨ï¼Ÿ
- [ ] å¯†é’¥æ˜¯å¦åœ¨ä¸ä½¿ç”¨æ—¶æ­£ç¡®æ¸…ç†ï¼Ÿ

## åŠ å¯†å®ç°
- [ ] æ˜¯å¦ä½¿ç”¨è®¤è¯åŠ å¯†æ¨¡å¼(AES-GCM)ï¼Ÿ
- [ ] å¯†é’¥é•¿åº¦æ˜¯å¦è¶³å¤Ÿ(256ä½)ï¼Ÿ
- [ ] æ˜¯å¦ä½¿ç”¨å”¯ä¸€çš„åˆå§‹åŒ–å‘é‡(IV)ï¼Ÿ
- [ ] æ˜¯å¦æ­£ç¡®å¤„ç†åŠ å¯†å¼‚å¸¸ï¼Ÿ

## è¾“å…¥éªŒè¯
- [ ] æ˜¯å¦éªŒè¯æ‰€æœ‰è¾“å…¥å‚æ•°ï¼Ÿ
- [ ] æ˜¯å¦é™åˆ¶è¾“å…¥æ•°æ®å¤§å°ï¼Ÿ
- [ ] æ˜¯å¦æ£€æŸ¥å­—ç¬¦ç¼–ç ï¼Ÿ
- [ ] æ˜¯å¦é˜²æ­¢ç¼“å†²åŒºæº¢å‡ºï¼Ÿ

## é”™è¯¯å¤„ç†
- [ ] é”™è¯¯ä¿¡æ¯æ˜¯å¦ä¸æ³„éœ²æ•æ„Ÿä¿¡æ¯ï¼Ÿ
- [ ] æ˜¯å¦è®°å½•å®‰å…¨ç›¸å…³äº‹ä»¶ï¼Ÿ
- [ ] å¼‚å¸¸æ˜¯å¦è¢«æ­£ç¡®å¤„ç†ï¼Ÿ
- [ ] æ˜¯å¦æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯åé¦ˆï¼Ÿ

## æ€§èƒ½è€ƒè™‘
- [ ] æ˜¯å¦ä½¿ç”¨ç¼“å­˜å‡å°‘é‡å¤åŠ å¯†ï¼Ÿ
- [ ] æ˜¯å¦æœ‰æ€§èƒ½ç›‘æ§ï¼Ÿ
- [ ] æ˜¯å¦é¿å…åœ¨å¾ªç¯ä¸­åŠ å¯†ï¼Ÿ
- [ ] æ˜¯å¦æœ‰è¶…æ—¶ä¿æŠ¤ï¼Ÿ

## æ—¥å¿—å’Œå®¡è®¡
- [ ] æ˜¯å¦è®°å½•åŠ å¯†æ“ä½œï¼Ÿ
- [ ] æ˜¯å¦ä¿æŠ¤æ—¥å¿—æ–‡ä»¶ï¼Ÿ
- [ ] æ˜¯å¦æœ‰å®¡è®¡è¿½è¸ªï¼Ÿ
- [ ] æ˜¯å¦ç¬¦åˆåˆè§„è¦æ±‚ï¼Ÿ
```

### 3. è¿ç»´æœ€ä½³å®è·µ

#### 3.1 æ—¥å¸¸è¿ç»´æ£€æŸ¥
```bash
#!/bin/bash
# æ—¥å¸¸è¿ç»´æ£€æŸ¥è„šæœ¬

DAILY_CHECKS_SCRIPT=$(cat << 'EOF'
#!/bin/bash

# æ—¥å¸¸åŠ å¯†ç³»ç»Ÿè¿ç»´æ£€æŸ¥
class DailyOpsCheck {
    constructor() {
        this.checks = []
        this.alerts = []
    }
    
    async performChecks() {
        await this.checkEncryptionSystem()
        await this.checkPerformanceMetrics()
        await this.checkSecurityEvents()
        await this.checkBackupStatus()
        await this.checkComplianceStatus()
        
        this.generateReport()
        this.sendAlertsIfNeeded()
    }
    
    async checkEncryptionSystem() {
        try {
            // æ£€æŸ¥å¯†é’¥æœ‰æ•ˆæ€§
            const keyValid = await this.verifyEncryptionKey()
            this.checks.push({
                name: 'Encryption Key Validity',
                status: keyValid ? 'PASS' : 'FAIL',
                message: keyValid ? 'All keys are valid' : 'Key validation failed'
            })
            
            // æ£€æŸ¥è§£å¯†æˆåŠŸç‡
            const successRate = await this.getDecryptionSuccessRate()
            this.checks.push({
                name: 'Decryption Success Rate',
                status: successRate > 0.99 ? 'PASS' : 'WARN',
                message: `Success rate: ${(successRate * 100).toFixed(2)}%`
            })
            
        } catch (error) {
            this.checks.push({
                name: 'Encryption System Check',
                status: 'ERROR',
                message: error.message
            })
        }
    }
    
    async checkPerformanceMetrics() {
        const metrics = await this.getPerformanceMetrics()
        
        this.checks.push({
            name: 'Average Encryption Time',
            status: metrics.avgEncryptionTime < 100 ? 'PASS' : 'WARN',
            message: `Avg: ${metrics.avgEncryptionTime}ms`
        })
        
        this.checks.push({
            name: 'Memory Usage',
            status: metrics.memoryUsage < 0.8 ? 'PASS' : 'WARN',
            message: `Usage: ${(metrics.memoryUsage * 100).toFixed(1)}%`
        })
    }
    
    generateReport() {
        const report = {
            timestamp: new Date().toISOString(),
            total_checks: this.checks.length,
            passed_checks: this.checks.filter(c => c.status === 'PASS').length,
            warning_checks: this.checks.filter(c => c.status === 'WARN').length,
            failed_checks: this.checks.filter(c => c.status === 'FAIL').length,
            error_checks: this.checks.filter(c => c.status === 'ERROR').length,
            details: this.checks
        }
        
        console.log(JSON.stringify(report, null, 2))
        return report
    }
}

module.exports = DailyOpsCheck
EOF
)

echo "${DAILY_CHECKS_SCRIPT}" > daily-ops-check.js
chmod +x daily-ops-check.js

# è®¾ç½®å®šæ—¶ä»»åŠ¡
(crontab -l 2>/dev/null; echo "0 9 * * * /usr/local/bin/node /opt/encryption/daily-ops-check.js") | crontab -

echo "æ—¥å¸¸è¿ç»´æ£€æŸ¥å·²é…ç½®ä¸ºæ¯æ—¥9ç‚¹æ‰§è¡Œ"
```

#### 3.2 åº”æ€¥å“åº”æµç¨‹
```java
// åº”æ€¥å“åº”ç³»ç»Ÿ
@Component
public class IncidentResponseSystem {
    
    private static final Logger logger = LoggerFactory.getLogger(IncidentResponseSystem.class);
    
    // å®‰å…¨äº‹ä»¶å“åº”
    @EventListener
    public void handleSecurityIncident(SecurityIncidentEvent event) {
        IncidentResponse response = determineResponseStrategy(event);
        
        try {
            switch (response.getSeverity()) {
                case CRITICAL:
                    handleCriticalIncident(event);
                    break;
                case HIGH:
                    handleHighPriorityIncident(event);
                    break;
                case MEDIUM:
                    handleMediumPriorityIncident(event);
                    break;
                case LOW:
                    handleLowPriorityIncident(event);
                    break;
            }
        } catch (Exception e) {
            logger.error("åº”æ€¥å“åº”æ‰§è¡Œå¤±è´¥", e);
            activateEmergencyMode();
        }
    }
    
    private void handleCriticalIncident(SecurityIncidentEvent event) {
        logger.error("CRITICAL: {}", event.getDescription());
        
        // ç«‹å³æ‰§è¡Œçš„å…³é”®æªæ–½
        immediateActions(event);
        
        // é€šçŸ¥ç›¸å…³äººå‘˜
        notifySecurityTeam(event);
        
        // è®°å½•è¯¦ç»†äº‹ä»¶æ—¥å¿—
        logSecurityIncident(event);
        
        // å¯åŠ¨å®¡è®¡æ¨¡å¼
        enableAuditMode();
        
        // å¦‚æœéœ€è¦ï¼Œéš”ç¦»å—å½±å“çš„ç³»ç»Ÿ
        if (event.requiresIsolation()) {
            isolateAffectedSystems(event);
        }
    }
    
    private void immediateActions(SecurityIncidentEvent event) {
        // å†»ç»“å½“å‰å¯†é’¥
        freezeCurrentKeys();
        
        // æ¿€æ´»å¤‡ç”¨å¯†é’¥
        activateBackupKeys();
        
        // æå‡ç›‘æ§çº§åˆ«
        increaseMonitoringLevel();
        
        // å‡†å¤‡ç¾éš¾æ¢å¤
        prepareDisasterRecovery();
    }
}
```

## æŠ€æœ¯æ–¹æ¡ˆ

### 1. æŠ€æœ¯é€‰å‹

#### 1.1 åŠ å¯†ç®—æ³•é€‰æ‹©
- **å¯¹ç§°åŠ å¯†**: AES-256-GCM (æ¨è)
  - å¯†é’¥é•¿åº¦: 256ä½
  - æ¨¡å¼: GCM (Galois/Counter Mode)
  - ä¼˜åŠ¿: å®‰å…¨æ€§é«˜ã€æ€§èƒ½å¥½ã€è®¤è¯åŠ å¯†ä¸€ä½“åŒ–

- **éå¯¹ç§°åŠ å¯†**: RSA-2048 (ç”¨äºå¯†é’¥äº¤æ¢)
  - ç”¨äºåŠ å¯†å¯¹ç§°å¯†é’¥
  - æ”¯æŒæ•°å­—ç­¾åéªŒè¯

#### 1.2 å¯†é’¥ç®¡ç†
- **å¯†é’¥æ´¾ç”Ÿ**: PBKDF2 (Password-Based Key Derivation Function 2)
  - è¿­ä»£æ¬¡æ•°: 100,000æ¬¡
  - ç›å€¼é•¿åº¦: 32å­—èŠ‚
  - è¾“å‡ºé•¿åº¦: 256ä½

- **å¯†é’¥å­˜å‚¨**
  - å¼€å‘ç¯å¢ƒ: ç¯å¢ƒå˜é‡æˆ–æœ¬åœ°å¯†é’¥æ–‡ä»¶
  - ç”Ÿäº§ç¯å¢ƒ: ä¸“ä¸šå¯†é’¥ç®¡ç†ç³»ç»Ÿ (KMS/HSM)

### 2. å®ç°æ¶æ„

```
é…ç½®æ–‡ä»¶ â†’ åŠ å¯†å­˜å‚¨ â†’ è¿è¡Œæ—¶è§£å¯† â†’ åº”ç”¨ä½¿ç”¨
    â†“           â†“          â†“         â†“
æ˜æ–‡é…ç½® â†’ AESåŠ å¯† â†’ å¯†æ–‡é…ç½® â†’ å†…å­˜è§£å¯† â†’ ä¸šåŠ¡é€»è¾‘
```

### 3. æ ¸å¿ƒç»„ä»¶

#### 3.1 åŠ å¯†å·¥å…·ç±» (EncryptUtil)
- å­—ç¬¦ä¸²åŠ å¯†/è§£å¯†
- æ–‡ä»¶åŠ å¯†/è§£å¯†
- å¯†é’¥æ´¾ç”Ÿå’Œç®¡ç†

#### 3.2 é…ç½®å¤„ç†å™¨ (EncryptedPropertyProcessor)
- Spring Booté…ç½®å±æ€§å¤„ç†å™¨
- è‡ªåŠ¨è§£å¯†é…ç½®å€¼
- æ”¯æŒåµŒå¥—é…ç½®è§£å¯†

#### 3.3 å¯†é’¥ç®¡ç†å™¨ (KeyManager)
- å¯†é’¥ç”Ÿæˆå’Œå­˜å‚¨
- å¯†é’¥è½®æ¢æ”¯æŒ
- å¤šç¯å¢ƒå¯†é’¥ç®¡ç†

## å®ç°åŸç†

### åŠ å¯†æµç¨‹å¯è§†åŒ–å›¾è§£

ğŸ“Š **å®Œæ•´æµç¨‹å›¾è¯·ç‚¹å‡»æŸ¥çœ‹**: [å¯†ç åŠ å¯†æµç¨‹å›¾.svg](./images/å¯†ç åŠ å¯†æµç¨‹å›¾.svg)

![åŠ å¯†æµç¨‹æ€»è§ˆ](password_encryption_flow_diagram.png)

**ğŸ”— åœ¨çº¿æŸ¥çœ‹å®Œæ•´æµç¨‹å›¾**: 
- ğŸ“ æ–‡ä»¶è·¯å¾„: `docs/images/å¯†ç åŠ å¯†æµç¨‹å›¾.svg`
- ğŸŒ åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€å³å¯æŸ¥çœ‹çŸ¢é‡æµç¨‹å›¾

> **æç¤º**: SVGç‰ˆæœ¬åŒ…å«å½©è‰²æµç¨‹å›¾ã€çŸ¢é‡å›¾å½¢å’Œè¯¦ç»†çš„æŠ€æœ¯è¯´æ˜ï¼Œæ¯”çº¯ASCIIå›¾æ›´ç›´è§‚æ˜“æ‡‚ï¼

> **ğŸš€ SVGç‰ˆæœ¬åŒ…å«ä»¥ä¸‹ä¼˜åŠ¿**:
> - ğŸ¨ **å½©è‰²æµç¨‹å›¾**: ä½¿ç”¨é¢œè‰²ç¼–ç åŒºåˆ†ä¸åŒé˜¶æ®µçš„å¤„ç†è¿‡ç¨‹
> - ğŸ“ **çŸ¢é‡å›¾å½¢**: æ— æŸç¼©æ”¾ï¼Œé€‚åˆå„ç§å°ºå¯¸çš„æ˜¾ç¤ºè®¾å¤‡
> - ğŸ”§ **æŠ€æœ¯ç»†èŠ‚**: åŒ…å«å‚æ•°é…ç½®ã€æ€§èƒ½ä¼˜åŒ–å’Œæœ€ä½³å®è·µæŒ‡å—
> - âš¡ **æ€§èƒ½ä¼˜åŒ–**: è½»é‡çº§æ–‡ä»¶ï¼ŒåŠ è½½é€Ÿåº¦å¿«

### Spring Booté…ç½®è§£ææµç¨‹

ğŸ”— **è¯¦ç»†æµç¨‹å›¾è¯·ç‚¹å‡»æŸ¥çœ‹**: [å¯†ç åŠ å¯†æµç¨‹å›¾.svg](./images/å¯†ç åŠ å¯†æµç¨‹å›¾.svg#spring-booté…ç½®è§£ææµç¨‹)

### é…ç½®æ–‡ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†

ğŸ”— **è¯¦ç»†æµç¨‹å›¾è¯·ç‚¹å‡»æŸ¥çœ‹**: [å¯†ç åŠ å¯†æµç¨‹å›¾.svg](./images/å¯†ç åŠ å¯†æµç¨‹å›¾.svg#é…ç½®æ–‡ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†)

## æŠ€æœ¯å®ç°

### 1. Mavenä¾èµ–é…ç½®

```xml
<dependencies>
    <!-- Spring Boot Configuration Processor -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-configuration-processor</artifactId>
        <optional>true</option>
    </dependency>
    
    <!-- JCEåŠ å¯†åº“ -->
    <dependency>
        <groupId>org.bouncycastle</groupId>
        <artifactId>bcprov-jdk15on</artifactId>
        <version>1.70</version>
    </dependency>
    
    <!-- å¯†é’¥åº“ -->
    <dependency>
        <groupId>com.typesafe</groupId>
        <artifactId>config</artifactId>
        <version>1.4.3</version>
    </dependency>
</dependencies>
```

### 2. åŠ å¯†å·¥å…·ç±»å®ç°

```java
package com.bing.framework.security;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.Security;
import java.security.SecureRandom;
import java.util.Base64;

/**
 * åŠ å¯†å·¥å…·ç±»
 * æ”¯æŒAES-256-GCMåŠ å¯†è§£å¯†
 * 
 * @author zhengbing
 * @date 2025-11-20
 */
@Component
public class EncryptUtil {
    
    static {
        // æ³¨å†ŒBouncyCastleå®‰å…¨æä¾›ç¨‹åº
        Security.addProvider(new BouncyCastleProvider());
    }
    
    private static final String ALGORITHM = "AES";
    private static final String TRANSFORMATION = "AES/GCM/NoPadding";
    private static final int KEY_LENGTH = 256;
    private static final int IV_LENGTH = 12; // GCMæ¨¡å¼æ¨è12å­—èŠ‚IV
    private static final int TAG_LENGTH = 128; // è®¤è¯æ ‡ç­¾é•¿åº¦
    private static final int PBKDF2_ITERATIONS = 100000;
    private static final int PBKDF2_KEY_LENGTH = 256;
    
    /**
     * ç”Ÿæˆéšæœºå¯†é’¥
     */
    public static String generateKey() throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance(ALGORITHM);
        keyGenerator.init(KEY_LENGTH);
        SecretKey secretKey = keyGenerator.generateKey();
        return Base64.getEncoder().encodeToString(secretKey.getEncoded());
    }
    
    /**
     * ä½¿ç”¨å¯†ç æ´¾ç”Ÿå¯†é’¥
     */
    public static SecretKey deriveKey(String password, byte[] salt) throws Exception {
        javax.crypto.SecretKeyFactory factory = 
            javax.crypto.SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        javax.crypto.spec.PBEKeySpec spec = new javax.crypto.spec.PBEKeySpec(
            password.toCharArray(), 
            salt, 
            PBKDF2_ITERATIONS, 
            PBKDF2_KEY_LENGTH
        );
        SecretKey tmp = factory.generateSecret(spec);
        return new SecretKeySpec(tmp.getEncoded(), ALGORITHM);
    }
    
    /**
     * AES-GCMåŠ å¯†
     */
    public static String encrypt(String plainText, String base64Key) throws Exception {
        byte[] keyBytes = Base64.getDecoder().decode(base64Key);
        SecretKey secretKey = new SecretKeySpec(keyBytes, ALGORITHM);
        
        // ç”ŸæˆéšæœºIV
        byte[] iv = new byte[IV_LENGTH];
        SecureRandom random = new SecureRandom();
        random.nextBytes(iv);
        
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        GCMParameterSpec gcmSpec = new GCMParameterSpec(TAG_LENGTH, iv);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, gcmSpec);
        
        byte[] encryptedData = cipher.doFinal(plainText.getBytes("UTF-8"));
        
        // æ‹¼æ¥IVå’ŒåŠ å¯†æ•°æ®
        byte[] combined = new byte[iv.length + encryptedData.length];
        System.arraycopy(iv, 0, combined, 0, iv.length);
        System.arraycopy(encryptedData, 0, combined, iv.length, encryptedData.length);
        
        return Base64.getEncoder().encodeToString(combined);
    }
    
    /**
     * AES-GCMè§£å¯†
     */
    public static String decrypt(String encryptedText, String base64Key) throws Exception {
        byte[] keyBytes = Base64.getDecoder().decode(base64Key);
        SecretKey secretKey = new SecretKeySpec(keyBytes, ALGORITHM);
        
        byte[] combined = Base64.getDecoder().decode(encryptedText);
        
        // æå–IVå’ŒåŠ å¯†æ•°æ®
        byte[] iv = new byte[IV_LENGTH];
        byte[] encryptedData = new byte[combined.length - IV_LENGTH];
        System.arraycopy(combined, 0, iv, 0, IV_LENGTH);
        System.arraycopy(combined, IV_LENGTH, encryptedData, 0, encryptedData.length);
        
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        GCMParameterSpec gcmSpec = new GCMParameterSpec(TAG_LENGTH, iv);
        cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec);
        
        byte[] decryptedData = cipher.doFinal(encryptedData);
        return new String(decryptedData, "UTF-8");
    }
    
    /**
     * ä½¿ç”¨å¯†ç åŠ å¯†
     */
    public static String encryptWithPassword(String plainText, String password) throws Exception {
        byte[] salt = new byte[32];
        SecureRandom random = new SecureRandom();
        random.nextBytes(salt);
        
        SecretKey secretKey = deriveKey(password, salt);
        String key = Base64.getEncoder().encodeToString(secretKey.getEncoded());
        
        String encrypted = encrypt(plainText, key);
        
        // å°†ç›å€¼é™„åŠ åˆ°åŠ å¯†ç»“æœä¸­
        byte[] saltAndCipher = new byte[salt.length + encrypted.getBytes().length];
        System.arraycopy(salt, 0, saltAndCipher, 0, salt.length);
        System.arraycopy(encrypted.getBytes(), 0, saltAndCipher, salt.length, encrypted.getBytes().length);
        
        return Base64.getEncoder().encodeToString(saltAndCipher);
    }
    
    /**
     * ä½¿ç”¨å¯†ç è§£å¯†
     */
    public static String decryptWithPassword(String encryptedText, String password) throws Exception {
        byte[] saltAndCipher = Base64.getDecoder().decode(encryptedText);
        
        byte[] salt = new byte[32];
        byte[] cipherBytes = new byte[saltAndCipher.length - salt.length];
        System.arraycopy(saltAndCipher, 0, salt, 0, salt.length);
        System.arraycopy(saltAndCipher, salt.length, cipherBytes, 0, cipherBytes.length);
        
        SecretKey secretKey = deriveKey(password, salt);
        String key = Base64.getEncoder().encodeToString(secretKey.getEncoded());
        
        return decrypt(new String(cipherBytes), key);
    }
}
```

### 3. é…ç½®å±æ€§å¤„ç†å™¨

```java
package com.bing.framework.security;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * åŠ å¯†é…ç½®å±æ€§å¤„ç†å™¨
 * è‡ªåŠ¨è§£å¯†ä»¥ENC(å¼€å¤´çš„é…ç½®å€¼
 * 
 * @author zhengbing
 * @date 2025-11-20
 */
@Component
public class EncryptedPropertyProcessor {
    
    private final Map<String, String> decryptedCache = new ConcurrentHashMap<>();
    private final EncryptUtil encryptUtil;
    
    @Value("${app.encryption.key:}")
    private String encryptionKey;
    
    public EncryptedPropertyProcessor(EncryptUtil encryptUtil) {
        this.encryptUtil = encryptUtil;
    }
    
    /**
     * è§£å¯†é…ç½®å€¼
     */
    public String decryptProperty(String propertyValue) {
        if (propertyValue == null || !propertyValue.startsWith("ENC(") || !propertyValue.endsWith(")")) {
            return propertyValue;
        }
        
        String encryptedValue = propertyValue.substring(4, propertyValue.length() - 1);
        
        // æ£€æŸ¥ç¼“å­˜
        String cacheKey = encryptionKey + ":" + encryptedValue;
        return decryptedCache.computeIfAbsent(cacheKey, k -> {
            try {
                return encryptUtil.decrypt(encryptedValue, encryptionKey);
            } catch (Exception e) {
                throw new RuntimeException("Failed to decrypt property: " + propertyValue, e);
            }
        });
    }
    
    /**
     * åŠ å¯†é…ç½®å€¼
     */
    public String encryptProperty(String plainValue) {
        try {
            return "ENC(" + encryptUtil.encrypt(plainValue, encryptionKey) + ")";
        } catch (Exception e) {
            throw new RuntimeException("Failed to encrypt property: " + plainValue, e);
        }
    }
    
    /**
     * æ¸…ç†è§£å¯†ç¼“å­˜
     */
    public void clearCache() {
        decryptedCache.clear();
    }
}
```

### 4. é…ç½®å±æ€§æº

```java
package com.bing.framework.security;

import org.springframework.core.env.MapPropertySource;

import java.util.HashMap;
import java.util.Map;

/**
 * åŠ å¯†å±æ€§æº
 * è‡ªåŠ¨è§£å¯†é…ç½®å€¼
 * 
 * @author zhengbing
 * @date 2025-11-20
 */
public class EncryptedPropertySource extends MapPropertySource {
    
    private final EncryptedPropertyProcessor processor;
    
    public EncryptedPropertySource(String name, 
                                 Map<String, Object> source, 
                                 EncryptedPropertyProcessor processor) {
        super(name, source);
        this.processor = processor;
    }
    
    @Override
    public Object getProperty(String name) {
        Object value = super.getProperty(name);
        if (value instanceof String) {
            return processor.decryptProperty((String) value);
        }
        return value;
    }
    
    @Override
    public Map<String, Object> getSource() {
        Map<String, Object> decryptedSource = new HashMap<>();
        for (Map.Entry<String, Object> entry : super.getSource().entrySet()) {
            Object value = entry.getValue();
            if (value instanceof String) {
                decryptedSource.put(entry.getKey(), processor.decryptProperty((String) value));
            } else {
                decryptedSource.put(entry.getKey(), value);
            }
        }
        return decryptedSource;
    }
}
```

### 5. Spring Booté…ç½®ç±»

```java
package com.bing.framework.config;

import com.bing.framework.security.EncryptedPropertyProcessor;
import com.bing.framework.security.EncryptedPropertySource;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.MapPropertySource;

import java.util.HashMap;
import java.util.Map;

/**
 * åŠ å¯†é…ç½®å±æ€§é…ç½®
 * 
 * @author zhengbing
 * @date 2025-11-20
 */
@Configuration
public class EncryptedPropertyConfig {
    
    /**
     * åŠ å¯†é…ç½®å±æ€§å¤„ç†å™¨
     */
    @Bean
    public EncryptedPropertyProcessor encryptedPropertyProcessor() {
        return new EncryptedPropertyProcessor();
    }
    
    /**
     * åŠ å¯†å±æ€§é…ç½®
     */
    @Bean
    @ConfigurationProperties(prefix = "app.encrypted")
    public EncryptedProperties encryptedProperties() {
        return new EncryptedProperties();
    }
    
    /**
     * åŠ å¯†å±æ€§
     */
    public static class EncryptedProperties {
        private String databasePassword;
        private String redisPassword;
        private String jwtSecret;
        private String apiKey;
        
        // Getters and Setters
        public String getDatabasePassword() { return databasePassword; }
        public void setDatabasePassword(String databasePassword) { 
            this.databasePassword = databasePassword; 
        }
        
        public String getRedisPassword() { return redisPassword; }
        public void setRedisPassword(String redisPassword) { 
            this.redisPassword = redisPassword; 
        }
        
        public String getJwtSecret() { return jwtSecret; }
        public void setJwtSecret(String jwtSecret) { 
            this.jwtSecret = jwtSecret; 
        }
        
        public String getApiKey() { return apiKey; }
        public void setApiKey(String apiKey) { 
            this.apiKey = apiKey; 
        }
    }
}
```

## ä½¿ç”¨ç¤ºä¾‹

### 1. application.ymlé…ç½®

```yaml
# åŠ å¯†é…ç½®
app:
  encryption:
    key: ${ENCRYPTION_KEY:your-base64-encryption-key-here}
  
  # åŠ å¯†åçš„æ•æ„Ÿä¿¡æ¯
  encrypted:
    database-password: ENC(AESåŠ å¯†åçš„æ•°æ®åº“å¯†ç )
    redis-password: ENC(AESåŠ å¯†åçš„Rediså¯†ç )
    jwt-secret: ENC(AESåŠ å¯†åçš„JWTå¯†é’¥)
    api-key: ENC(AESåŠ å¯†åçš„APIå¯†é’¥)

# æœªåŠ å¯†çš„é…ç½®
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/bing_framework
    username: ${DB_USERNAME:root}
    password: ${app.encrypted.database-password}
  
  redis:
    host: localhost
    port: 6379
    password: ${app.encrypted.redis-password}

# JWTé…ç½®
jwt:
  secret: ${app.encrypted.jwt-secret}
  expiration: 86400
```

### 2. é…ç½®åŠ å¯†å·¥å…·

```java
package com.bing.framework.security;

import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

/**
 * é…ç½®åŠ å¯†å·¥å…·
 * ç”¨äºç”Ÿæˆå’ŒåŠ å¯†é…ç½®
 * 
 * @author zhengbing
 * @date 2025-11-20
 */
@Component
public class ConfigEncryptionTool implements CommandLineRunner {
    
    private final EncryptUtil encryptUtil;
    
    public ConfigEncryptionTool(EncryptUtil encryptUtil) {
        this.encryptUtil = encryptUtil;
    }
    
    @Override
    public void run(String... args) throws Exception {
        if (args.length > 0 && "encrypt".equals(args[0])) {
            if (args.length < 3) {
                System.out.println("Usage: java -jar app.jar encrypt <key> <plaintext>");
                System.exit(1);
            }
            
            String key = args[1];
            String plainText = args[2];
            
            String encrypted = encryptUtil.encrypt(plainText, key);
            System.out.println("Encrypted: ENC(" + encrypted + ")");
            
            String decrypted = encryptUtil.decrypt(encrypted, key);
            System.out.println("Decrypted: " + decrypted);
        }
    }
}
```

## å¯†é’¥ç®¡ç†ç­–ç•¥

### 1. å¼€å‘ç¯å¢ƒ
```bash
# ç¯å¢ƒå˜é‡æ–¹å¼
export ENCRYPTION_KEY=$(openssl rand -base64 32)

# æœ¬åœ°å¯†é’¥æ–‡ä»¶
echo "your-encryption-key-here" > ~/.encryption-key
```

### 2. æµ‹è¯•ç¯å¢ƒ
```yaml
# application-test.yml
app:
  encryption:
    key-file: /etc/keys/encryption.key
```

### 3. ç”Ÿäº§ç¯å¢ƒ
- **é€‰é¡¹1**: Kubernetes Secrets
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: encryption-key
type: Opaque
data:
  key: <base64-encoded-encryption-key>
```

- **é€‰é¡¹2**: AWS KMS/Azure Key Vault
```java
@Value("${cloud.aws.kms.key-id}")
private String kmsKeyId;

// ä½¿ç”¨KMSåŠ å¯†/è§£å¯†
String encrypted = kmsClient.encrypt(plainText);
String decrypted = kmsClient.decrypt(encrypted);
```

## å®‰å…¨æ€§åˆ†æ

### 1. ä¼˜åŠ¿
- **å¼ºåŠ å¯†**: AES-256-GCMæä¾›å†›äº‹çº§å®‰å…¨æ€§
- **è®¤è¯åŠ å¯†**: GCMæ¨¡å¼æä¾›è®¤è¯åŠŸèƒ½ï¼Œé˜²æ­¢ç¯¡æ”¹
- **å¯†é’¥æ´¾ç”Ÿ**: PBKDF2é˜²æ­¢æš´åŠ›ç ´è§£
- **è‡ªåŠ¨è§£å¯†**: å¯¹åº”ç”¨é€æ˜ï¼Œè‡ªåŠ¨å¤„ç†åŠ å¯†/è§£å¯†
- **çµæ´»é…ç½®**: æ”¯æŒå¤šç§å¯†é’¥ç®¡ç†æ–¹å¼

### 2. é£é™©å’Œç¼“è§£
- **å¯†é’¥æ³„éœ²**: ä½¿ç”¨ä¸“ä¸šKMSç³»ç»Ÿï¼Œå®šæœŸè½®æ¢å¯†é’¥
- **å†…å­˜æ³„éœ²**: è§£å¯†åç«‹å³ä½¿ç”¨ï¼ŒåŠæ—¶æ¸…ç†å†…å­˜
- **é…ç½®æ³„éœ²**: ç¡®ä¿é…ç½®æ–‡ä»¶è®¿é—®æƒé™ï¼Œä½¿ç”¨ç¯å¢ƒå˜é‡

### 3. æ€§èƒ½å½±å“
- **å¯åŠ¨æ—¶é—´**: é¦–æ¬¡è§£å¯†éœ€è¦æ—¶é—´ï¼Œåç»­ä½¿ç”¨ç¼“å­˜
- **å†…å­˜ä½¿ç”¨**: è§£å¯†åç¼“å­˜åœ¨å†…å­˜ä¸­
- **è®¡ç®—å¼€é”€**: AES-GCMåŠ è§£å¯†æ€§èƒ½ä¼˜ç§€

## éƒ¨ç½²æ­¥éª¤

### 1. ç”Ÿæˆå¯†é’¥
```bash
# ç”Ÿæˆéšæœºå¯†é’¥
KEY=$(java -cp app.jar com.bing.framework.security.EncryptUtil generateKey)
echo "Encryption Key: $KEY"

# åŠ å¯†æ•æ„Ÿä¿¡æ¯
ENCRYPTED_DB_PASSWORD=$(java -cp app.jar com.bing.framework.security.EncryptUtil encrypt "your-db-password" "$KEY")
echo "Encrypted DB Password: ENC($ENCRYPTED_DB_PASSWORD)"
```

### 2. é…ç½®åº”ç”¨
```yaml
app:
  encryption:
    key: ${ENCRYPTION_KEY}
  encrypted:
    database-password: ENC(${ENCRYPTED_DB_PASSWORD})
```

### 3. ç¯å¢ƒå˜é‡è®¾ç½®
```bash
export ENCRYPTION_KEY="your-base64-key"
export ENCRYPTED_DB_PASSWORD="ENC(encrypted-password)"
```

## ç›‘æ§å’Œå®¡è®¡

### 1. è§£å¯†æ“ä½œæ—¥å¿—
```java
// åœ¨EncryptedPropertyProcessorä¸­æ·»åŠ æ—¥å¿—
log.info("Decrypting property: {}", propertyName.substring(0, 10) + "...");
// è®°å½•è§£å¯†æ“ä½œï¼Œä½†ä¸è®°å½•æ˜æ–‡å†…å®¹
```

### 2. å¯†é’¥è®¿é—®å®¡è®¡
- è®°å½•å¯†é’¥è¯»å–æ“ä½œ
- ç›‘æ§å¼‚å¸¸è§£å¯†å¤±è´¥
- è®¾ç½®å¯†é’¥è®¿é—®æƒé™

## æ€»ç»“

æœ¬æ–¹æ¡ˆæä¾›äº†å®Œæ•´çš„é…ç½®æ–‡ä»¶å¯†ç åŠ å¯†æŠ€æœ¯å®ç°ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **å®‰å…¨å¯é **: é‡‡ç”¨AES-256-GCMå†›äº‹çº§åŠ å¯†ç®—æ³•
2. **æ˜“äºé›†æˆ**: ä¸Spring Bootæ— ç¼é›†æˆï¼Œå¯¹ä¸šåŠ¡ä»£ç é€æ˜
3. **çµæ´»é…ç½®**: æ”¯æŒå¤šç§å¯†é’¥ç®¡ç†æ–¹å¼
4. **æ€§èƒ½ä¼˜ç§€**: ä½¿ç”¨ç¼“å­˜æœºåˆ¶ï¼Œæœ€å°åŒ–æ€§èƒ½å½±å“
5. **ç”Ÿäº§å°±ç»ª**: æ”¯æŒå¤šç§éƒ¨ç½²ç¯å¢ƒå’Œå¯†é’¥ç®¡ç†ç­–ç•¥

å»ºè®®åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨æ—¶ï¼Œé…åˆä¸“ä¸šçš„å¯†é’¥ç®¡ç†ç³»ç»Ÿ(KMS)ä¸€èµ·ä½¿ç”¨ï¼Œä»¥è·å¾—æœ€ä½³çš„å®‰å…¨æ€§ä¿éšœã€‚