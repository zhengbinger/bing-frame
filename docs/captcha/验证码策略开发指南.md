# 验证码策略开发指南

## 概述

本指南详细说明如何在bing-framework项目中开发新的验证码策略。本系统采用策略模式设计，具有良好的扩展性，可以轻松添加新的验证码类型。

## 架构设计

### 策略模式

验证码系统采用策略模式，主要组件包括：

- **CaptchaStrategy**: 验证码策略接口
- **CaptchaStrategyFactory**: 策略工厂，负责策略注册和获取
- **CaptchaResult**: 验证码结果基类
- **CaptchaConfig**: 验证码配置类

### 组件关系图

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│ CaptchaStrategy │    │ CaptchaStrategy  │    │ CaptchaStrategy │
│    Interface    │◄───┤   Factory        ├────►│  Implementations│
└─────────────────┘    └──────────────────┘    └─────────────────┘
         ▲                      ▲                       ▲
         │                      │                       │
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  CaptchaResult  │    │ CaptchaConfig    │    │   Controller    │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

## 开发步骤

### 1. 定义验证码结果类

首先创建验证码结果的实体类，继承自 `CaptchaResult`：

```java
/**
 * 自定义验证码结果
 * [实现方式说明]
 * [主要用途]
 * 
 * @author zhengbing
 * @date YYYY-MM-DD
 */
@Data
public class CustomCaptchaResult extends CaptchaResult {
    
    /**
     * 自定义验证码数据
     */
    private CustomCaptchaData captchaData;
    
    /**
     * 默认构造函数
     */
    public CustomCaptchaResult() {
        super();
    }
    
    /**
     * 构造函数
     * @param captchaKey 验证码键
     * @param captchaType 验证码类型
     * @param expireTime 过期时间
     * @param captchaData 验证码数据
     */
    public CustomCaptchaResult(String captchaKey, String captchaType, 
                              long expireTime, CustomCaptchaData captchaData) {
        super();
        setCaptchaKey(captchaKey);
        setCaptchaType(captchaType);
        setExpireTime(expireTime);
        this.captchaData = captchaData;
    }
}
```

### 2. 定义验证码数据类

创建验证码数据类：

```java
/**
 * 自定义验证码数据
 * [实现方式说明]
 * [主要用途]
 * 
 * @author zhengbing
 * @date YYYY-MM-DD
 */
@Data
public class CustomCaptchaData {
    
    /**
     * 验证码内容
     */
    private String content;
    
    /**
     * 额外数据
     */
    private Map<String, Object> extraData;
    
    /**
     * 时间戳
     */
    private long timestamp;
}
```

### 3. 实现验证码策略

创建验证码策略实现类：

```java
/**
 * 自定义验证码策略实现
 * [实现方式说明]
 * [主要用途]
 * 
 * @author zhengbing
 * @date YYYY-MM-DD
 */
@Component("custom")
@Slf4j
public class CustomCaptchaStrategy implements CaptchaStrategy {
    
    @Autowired
    private RedisUtil redisUtil;
    
    @Autowired
    private CaptchaConfig captchaConfig;
    
    @Override
    public CaptchaResult generateCaptcha(String key) {
        log.debug("生成自定义验证码，key: {}", key);
        
        // 1. 验证输入参数
        if (StringUtils.isBlank(key)) {
            log.warn("验证码key不能为空");
            return null;
        }
        
        // 2. 生成验证码数据
        CustomCaptchaData captchaData = generateCustomCaptchaData();
        
        // 3. 创建验证码结果
        String captchaKey = "captcha:custom:" + key;
        long expireTime = System.currentTimeMillis() + 
                         captchaConfig.getExpireMinutes() * 60 * 1000;
        
        CustomCaptchaResult result = new CustomCaptchaResult(
            captchaKey, "custom", expireTime, captchaData);
        
        // 4. 存储到Redis
        try {
            redisUtil.set(captchaKey, captchaData, 
                         captchaConfig.getExpireMinutes(), TimeUnit.MINUTES);
            log.debug("验证码存储成功，key: {}", captchaKey);
        } catch (Exception e) {
            log.error("验证码存储失败，key: {}, 错误: {}", captchaKey, e.getMessage());
            throw new CaptchaException("验证码生成失败");
        }
        
        return result;
    }
    
    @Override
    public boolean validateCaptcha(String key, String code) {
        log.debug("验证自定义验证码，key: {}, code: {}", key, code);
        
        // 1. 验证输入参数
        if (StringUtils.isAnyBlank(key, code)) {
            log.warn("验证码key或code为空");
            return false;
        }
        
        // 2. 获取存储的验证码数据
        String captchaKey = "captcha:custom:" + key;
        CustomCaptchaData storedData = redisUtil.get(captchaKey, CustomCaptchaData.class);
        
        if (storedData == null) {
            log.warn("验证码已过期或不存在，key: {}", captchaKey);
            return false;
        }
        
        // 3. 执行验证逻辑
        boolean isValid = validateCode(storedData, code);
        
        // 4. 验证成功后清理
        if (isValid) {
            try {
                redisUtil.delete(captchaKey);
                log.debug("验证码验证成功，已清理，key: {}", captchaKey);
            } catch (Exception e) {
                log.error("验证码清理失败，key: {}, 错误: {}", captchaKey, e.getMessage());
            }
        }
        
        return isValid;
    }
    
    @Override
    public String getType() {
        return "custom";
    }
    
    @Override
    public void cleanCaptcha(String key) {
        log.debug("清理自定义验证码，key: {}", key);
        
        if (StringUtils.isBlank(key)) {
            log.warn("验证码key不能为空");
            return;
        }
        
        String captchaKey = "captcha:custom:" + key;
        try {
            redisUtil.delete(captchaKey);
            log.debug("验证码清理成功，key: {}", captchaKey);
        } catch (Exception e) {
            log.error("验证码清理失败，key: {}, 错误: {}", captchaKey, e.getMessage());
        }
    }
    
    /**
     * 生成自定义验证码数据
     */
    private CustomCaptchaData generateCustomCaptchaData() {
        CustomCaptchaData data = new CustomCaptchaData();
        data.setContent(generateRandomContent());
        data.setTimestamp(System.currentTimeMillis());
        data.setExtraData(generateExtraData());
        return data;
    }
    
    /**
     * 生成随机内容
     */
    private String generateRandomContent() {
        // 根据具体需求实现随机内容生成
        return "RANDOM_CONTENT_" + UUID.randomUUID().toString().substring(0, 8);
    }
    
    /**
     * 生成额外数据
     */
    private Map<String, Object> generateExtraData() {
        Map<String, Object> extraData = new HashMap<>();
        // 根据需要添加额外数据
        return extraData;
    }
    
    /**
     * 验证验证码
     */
    private boolean validateCode(CustomCaptchaData storedData, String inputCode) {
        // 实现具体的验证逻辑
        return storedData.getContent().equals(inputCode);
    }
}
```

### 4. 更新配置

在 `CaptchaConfig` 类中添加新验证码的配置项：

```java
/**
 * 验证码配置
 */
@Component
@ConfigurationProperties(prefix = "bing.captcha")
@Data
public class CaptchaConfig {
    
    // 现有配置...
    
    /**
     * 自定义验证码配置
     */
    private CustomConfig custom = new CustomConfig();
    
    @Data
    public static class CustomConfig {
        /**
         * 自定义配置项1
         */
        private String config1;
        
        /**
         * 自定义配置项2
         */
        private int config2;
    }
}
```

在 `application.yml` 中添加配置：

```yaml
bing:
  captcha:
    # 现有配置...
    custom:
      config1: "value1"
      config2: 100
```

### 5. 编写测试用例

创建对应的测试类：

```java
/**
 * 自定义验证码策略实现测试类
 * 测试CustomCaptchaStrategy的各项功能，包括验证码生成、验证和清理
 * 
 * 包含验证码生成、验证逻辑、Redis存储等核心功能测试
 * 通过Mockito模拟Redis操作和配置，确保测试的独立性和可靠性
 * 
 * @author zhengbing
 * @date YYYY-MM-DD
 */
class CustomCaptchaStrategyTest {

    @Mock
    private RedisUtil redisUtil;
    
    @Mock
    private CaptchaConfig captchaConfig;

    @InjectMocks
    private CustomCaptchaStrategy customCaptchaStrategy;

    @Test
    void generateCaptcha_shouldReturnValidCustomCaptchaResult() {
        // 测试实现...
    }
    
    @Test
    void validateCaptcha_shouldReturnTrueWhenCodeMatches() {
        // 测试实现...
    }
    
    // 更多测试用例...
}
```

### 6. 更新控制器（如果需要）

如果需要为新的验证码类型添加专门的控制器方法，在 `CaptchaController` 中添加：

```java
/**
 * 验证码控制器
 * 提供验证码生成和刷新的RESTful API接口
 * 
 * @author zhengbing
 * @date YYYY-MM-DD
 */
@Api(tags = "验证码管理", description = "提供验证码生成和刷新的API接口")
@RestController
@RequestMapping("/api/captcha")
@Slf4j
public class CaptchaController {
    
    @Autowired
    private CaptchaStrategyFactory captchaStrategyFactory;
    
    /**
     * 生成自定义验证码
     */
    @ApiOperation("生成自定义验证码")
    @GetMapping("/generate/custom")
    public Result<CaptchaResult> generateCustomCaptcha() {
        try {
            String key = UUID.randomUUID().toString().replace("-", "");
            CaptchaStrategy strategy = captchaStrategyFactory.getStrategy("custom");
            CaptchaResult result = strategy.generateCaptcha(key);
            return Result.success(result);
        } catch (Exception e) {
            log.error("生成自定义验证码失败", e);
            return Result.error("验证码生成失败");
        }
    }
}
```

## 最佳实践

### 1. 配置管理

- 所有可配置的参数都应该添加到 `CaptchaConfig` 类中
- 使用合理的默认值，确保系统可以在没有特殊配置的情况下正常运行
- 配置项应该有清晰的注释说明

### 2. 错误处理

- 合理处理各种异常情况
- 记录详细的日志信息，便于问题排查
- 对于用户友好的错误信息，避免暴露内部实现细节

### 3. 性能优化

- 验证码生成不应该消耗过多CPU或内存
- 合理使用缓存，避免重复生成相同内容的验证码
- 设置合适的过期时间，避免Redis中积累过多数据

### 4. 安全性

- 验证码应该具有一定的随机性和不可预测性
- 避免验证码内容过于简单或容易被猜测
- 验证成功后及时清理验证码数据

### 5. 可扩展性

- 设计时考虑未来的扩展需求
- 保持接口的一致性，便于维护
- 使用注解和配置实现依赖注入

## 常见问题

### 1. 策略注册失败

**问题**: 新的验证码策略无法被自动发现和注册

**解决方案**:
- 确保类添加了 `@Component` 注解，指定唯一的策略名称
- 检查Spring扫描路径是否包含策略类所在的包
- 查看启动日志，确认策略注册成功

### 2. Redis操作异常

**问题**: 验证码生成或验证时Redis操作失败

**解决方案**:
- 检查Redis连接配置是否正确
- 确认Redis服务是否正常运行
- 查看异常日志，定位具体的错误原因

### 3. 内存泄漏

**问题**: 长时间运行后系统内存使用量持续增长

**解决方案**:
- 确保验证码过期后能够正确清理
- 检查是否有未关闭的资源或对象引用
- 监控Redis中的验证码数据量

### 4. 性能问题

**问题**: 验证码生成或验证速度过慢

**解决方案**:
- 优化验证码生成的算法
- 使用异步处理或缓存机制
- 调整配置参数，平衡安全性和性能

## 监控和运维

### 1. 关键指标

- 验证码生成成功率
- 验证码验证成功率
- 平均生成耗时
- Redis连接数
- 内存使用量

### 2. 日志记录

- 记录生成和验证的统计信息
- 记录异常情况和错误信息
- 定期清理过期的日志文件

### 3. 报警机制

- 验证码生成失败率过高时发送报警
- Redis连接异常时发送报警
- 系统资源使用率过高时发送报警

通过遵循本指南，你可以轻松地在bing-framework项目中添加新的验证码策略，实现丰富的验证码功能。